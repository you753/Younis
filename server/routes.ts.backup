import type { Express, Request } from "express";
import { createServer, type Server } from "http";
import { z } from "zod";

interface AuthenticatedRequest extends Request {
  session: {
    userId?: number;
    tempUser?: {
      id: number;
      username: string;
      email: string;
      fullName: string;
      role: string;
    };
  } & Request['session'];
}
import { storage } from "./memory-storage";
import { 
  insertUserSchema, 
  insertSupplierSchema, 
  insertClientSchema, 
  insertProductSchema,
  insertSaleSchema,
  insertPurchaseSchema,
  insertEmployeeSchema,
  insertDeductionSchema,
  insertSalarySchema,
  insertProductCategorySchema,
  insertSupplierPaymentVoucherSchema,
  insertClientReceiptVoucherSchema,
  insertInventoryOpeningBalanceSchema,
  insertWithdrawalVoucherSchema,
  insertAccountingTreeSchema,

  insertPosTerminalSchema,
  insertPosSaleSchema,
  insertBranchTemplateSchema,
  insertBranchSupplierSchema,
  insertBranchClientSchema,
  insertBranchProductCategorySchema,
  insertBranchProductSchema,
  insertBranchSaleSchema,
  insertBranchSaleItemSchema,
  insertHolidaySchema,
  insertInventoryMovementSchema,
  insertGoodsIssueVoucherSchema,
  insertDebtSchema,
  insertDebtPaymentSchema,
  branchSuppliers,
  branchClients,
  branchProductCategories,
  branchProducts,
  branchSales,
  branchSaleItems,
  branches,
  branchEmployees,
  branchSalaries,
  branchAllowances,
  branchDeductions,
  branchEmployeeAttendance,
  companyInfo,
  inventoryMovements,
  products,
  goodsIssueVouchers,
  sales,
  clients
} from "@shared/schema";
import { uploadMiddleware, transcribeAudio } from "./voice";
import { handleAIChat } from "./ai-chat";
import { healthCalculator } from "./health-calculator";
import { handleBranchAccounting } from "./branch-accounting";
import { db, pool } from "./db";
import { eq, and, desc, gte, lte, sql } from "drizzle-orm";
import { 
  users, 
  products, 
  clients, 
  sales, 
  purchases, 
  branches, 
  branchProducts, 
  branchClients, 
  terminals,
  clientReceiptVouchers,
  suppliers,
  supplierPaymentVouchers
} from '../shared/schema';
import multer from 'multer';
import path from 'path';
import * as XLSX from 'xlsx';

// تمديد نوع Request لإضافة الجلسة
interface AuthenticatedRequest extends Request {
  session: {
    userId?: number;
    save: (callback: (err?: any) => void) => void;
    destroy: (callback: (err?: any) => void) => void;
  } & any;
}
import fs from 'fs';

// إعداد رفع الصور
const avatarStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadsDir = path.join(process.cwd(), 'uploads', 'avatars');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'avatar-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const avatarUpload = multer({
  storage: avatarStorage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('يُسمح فقط بملفات الصور (JPEG, JPG, PNG, GIF)'));
    }
  }
});

// إعداد رفع ملفات Excel
const excelStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadsDir = path.join(process.cwd(), 'uploads', 'excel');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'products-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const excelUpload = multer({
  storage: excelStorage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx
      'application/vnd.ms-excel', // .xls
      'text/csv' // .csv
    ];
    
    if (allowedTypes.includes(file.mimetype) || file.originalname.match(/\.(xlsx|xls|csv)$/i)) {
      return cb(null, true);
    } else {
      cb(new Error('يُسمح فقط بملفات Excel (.xlsx, .xls) أو CSV'));
    }
  }
});

export async function registerRoutes(app: Express): Promise<Server> {
  // خدمة الملفات المرفوعة
  app.use('/uploads', (req, res, next) => {
    res.header('Cross-Origin-Resource-Policy', 'cross-origin');
    next();
  });
  
  // خدمة الملفات الثابتة
  app.get('/uploads/:folder/:filename', (req, res) => {
    const { folder, filename } = req.params;
    const filePath = path.join(process.cwd(), 'uploads', folder, filename);
    res.sendFile(filePath);
  });

  // Dashboard
  app.get("/api/dashboard/stats", async (req, res) => {
    try {
      const stats = await storage.getDashboardStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });

  // Auth routes
  app.post("/api/auth/register", async (req, res) => {
    try {
      const { username, email, fullName, password, role } = req.body;
      
      if (!username || !email || !fullName || !password) {
        return res.status(400).json({ message: "جميع الحقول مطلوبة" });
      }

      // إنشاء المستخدم الجديد بدون فحص التكرار
      const newUser = await storage.createUser({
        username,
        email,
        fullName,
        password, // في الإنتاج يجب تشفير كلمة المرور
        role: role || 'user'
      });

      // تسجيل دخول المستخدم مباشرة بعد إنشاء الحساب
      const authReq = req as AuthenticatedRequest;
      authReq.session.userId = newUser.id;

      // إزالة كلمة المرور من الاستجابة
      const { password: _, ...safeUser } = newUser;
      res.status(201).json(safeUser);
    } catch (error) {
      console.error("Register error:", error);
      res.status(500).json({ message: "حدث خطأ أثناء إنشاء الحساب" });
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      console.log(`تسجيل دخول: اسم المستخدم="${username}", كلمة المرور="${password}"`);
      
      if (!username || !password) {
        return res.status(400).json({ message: "اسم المستخدم وكلمة المرور مطلوبان" });
      }

      // نظام دخول مؤقت مبسط
      if ((username === "admin" && password === "admin") || 
          (username === "YOUNIS1234" && password === "Aa123456")) {
        const tempUser = {
          id: 1,
          username: username,
          email: username === "admin" ? "admin@test.com" : "younis@test.com",
          fullName: username === "admin" ? "المدير العام" : "يونس المدير",
          role: "admin"
        };

        // حفظ المستخدم في الجلسة
        const authReq = req as AuthenticatedRequest;
        authReq.session.userId = tempUser.id;
        authReq.session.tempUser = tempUser;
        console.log(`تم حفظ المستخدم في الجلسة: ${tempUser.id}`);

        res.json(tempUser);
      } else {
        console.log(`بيانات دخول خاطئة`);
        return res.status(401).json({ message: "استخدم YOUNIS1234/Aa123456 أو admin/admin للدخول" });
      }
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "حدث خطأ أثناء تسجيل الدخول" });
    }
  });

  // التحقق من حالة المصادقة
  app.get("/api/auth/me", async (req, res) => {
    try {
      const authReq = req as AuthenticatedRequest;
      const userId = authReq.session.userId;
      
      if (!userId) {
        return res.status(401).json({ message: "غير مسجل دخول" });
      }

      // نظام مؤقت - إرجاع المستخدم المحفوظ في الجلسة
      if (authReq.session.tempUser) {
        res.json(authReq.session.tempUser);
        return;
      }

      // في حالة عدم وجود مستخدم مؤقت، إنشاء واحد
      const tempUser = {
        id: 1,
        username: "admin",
        email: "admin@test.com",
        fullName: "المدير العام",
        role: "admin"
      };
      
      authReq.session.tempUser = tempUser;
      res.json(tempUser);
    } catch (error) {
      console.error("Auth check error:", error);
      res.status(500).json({ message: "خطأ في التحقق من المصادقة" });
    }
  });

  app.post("/api/auth/logout", async (req, res) => {
    try {
      const authReq = req as AuthenticatedRequest;
      authReq.session.destroy(() => {
        res.json({ message: "تم تسجيل الخروج بنجاح" });
      });
    } catch (error) {
      console.error("Logout error:", error);
      res.status(500).json({ message: "خطأ في تسجيل الخروج" });
    }
  });

  app.get("/api/auth/status", async (req, res) => {
    try {
      const authReq = req as AuthenticatedRequest;
      const userId = authReq.session.userId;
      
      if (!userId) {
        return res.status(401).json({ message: "غير مسجل دخول" });
      }

      const currentUser = await storage.getUser(userId);
      if (!currentUser) {
        return res.status(404).json({ message: "المستخدم غير موجود" });
      }
      
      const { password, ...safeUser } = currentUser;
      res.json(safeUser);
    } catch (error) {
      res.status(500).json({ message: "فشل في جلب بيانات المستخدم" });
    }
  });

  app.put("/api/auth/profile", async (req, res) => {
    try {
      const authReq = req as AuthenticatedRequest;
      const userId = authReq.session.userId;
      
      if (!userId) {
        return res.status(401).json({ message: "غير مسجل دخول" });
      }
      
      const updatedUser = await storage.updateUser(userId, req.body);
      
      if (!updatedUser) {
        return res.status(404).json({ message: "المستخدم غير موجود" });
      }
      
      const { password, ...safeUser } = updatedUser;
      res.json(safeUser);
    } catch (error) {
      console.error("Profile update error:", error);
      res.status(500).json({ message: "فشل في تحديث الملف الشخصي" });
    }
  });

  // رفع الصورة الشخصية
  app.post("/api/auth/upload-avatar", avatarUpload.single('avatar'), async (req, res) => {
    try {
      const authReq = req as AuthenticatedRequest;
      const userId = authReq.session.userId;
      
      if (!userId) {
        return res.status(401).json({ message: "غير مسجل دخول" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "لم يتم رفع أي ملف" });
      }

      const avatarPath = `/uploads/avatars/${req.file.filename}`;
      
      const updatedUser = await storage.updateUser(userId, { avatar: avatarPath });
      
      if (!updatedUser) {
        return res.status(404).json({ message: "المستخدم غير موجود" });
      }

      res.json({ 
        message: "تم رفع الصورة بنجاح",
        avatarUrl: avatarPath 
      });
    } catch (error) {
      console.error("Avatar upload error:", error);
      res.status(500).json({ message: "فشل في رفع الصورة" });
    }
  });



  // Suppliers routes
  app.get("/api/suppliers", async (req, res) => {
    try {
      const allSuppliers = await storage.getAllSuppliers();
      
      // حساب الرصيد الحالي بناءً على سندات الصرف
      const suppliersWithCurrentBalance = await Promise.all(
        allSuppliers.map(async (supplier) => {
          try {
            // جلب سندات الصرف الخاصة بالمورد
            const paymentVouchers = await db.select()
              .from(supplierPaymentVouchers)
              .where(eq(supplierPaymentVouchers.supplierId, supplier.id));
            
            // حساب إجمالي المدفوعات
            const totalPayments = paymentVouchers.reduce((total, voucher) => {
              return total + parseFloat(voucher.amount || '0');
            }, 0);
            
            // الرصيد الحالي = الرصيد الافتتاحي - إجمالي المدفوعات
            const openingBalance = parseFloat(supplier.balance || '0');
            const currentBalance = openingBalance - totalPayments;
            
            console.log(`المورد ${supplier.name}: رصيد افتتاحي ${openingBalance}, مدفوعات ${totalPayments}, رصيد حالي ${currentBalance}`);
            
            return {
              ...supplier,
              currentBalance: currentBalance.toString(),
              totalPayments: totalPayments.toString()
            };
          } catch (error) {
            console.error(`خطأ في حساب رصيد المورد ${supplier.id}:`, error);
            return {
              ...supplier,
              currentBalance: supplier.balance || '0',
              totalPayments: '0'
            };
          }
        })
      );
      
      res.json(suppliersWithCurrentBalance);
    } catch (error) {
      console.error("Error fetching suppliers:", error);
      res.status(500).json({ message: "Failed to fetch suppliers" });
    }
  });

  app.post("/api/suppliers", async (req, res) => {
    try {
      console.log("بيانات المورد الواردة:", req.body);
      
      // تنظيف البيانات قبل التحقق
      const cleanedData = {
        ...req.body,
        creditLimit: req.body.creditLimit === '' ? null : req.body.creditLimit,
        balance: req.body.balance === '' ? '0' : req.body.balance,
        email: req.body.email === '' ? null : req.body.email,
        phone: req.body.phone === '' ? null : req.body.phone,
        address: req.body.address === '' ? null : req.body.address,
        taxNumber: req.body.taxNumber === '' ? null : req.body.taxNumber
      };
      
      const validatedData = insertSupplierSchema.parse(cleanedData);
      console.log("البيانات بعد التحقق:", validatedData);
      const supplier = await storage.createSupplier(validatedData);
      res.status(201).json(supplier);
    } catch (error: any) {
      console.error("خطأ في إضافة المورد:", error);
      res.status(400).json({ message: "بيانات المورد غير صحيحة", error: error?.message || "خطأ غير معروف" });
    }
  });

  app.put("/api/suppliers/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // تنظيف البيانات قبل التحقق
      const cleanedData = {
        ...req.body,
        creditLimit: req.body.creditLimit === '' ? null : req.body.creditLimit,
        balance: req.body.balance === '' ? '0' : req.body.balance,
        email: req.body.email === '' ? null : req.body.email,
        phone: req.body.phone === '' ? null : req.body.phone,
        address: req.body.address === '' ? null : req.body.address,
        taxNumber: req.body.taxNumber === '' ? null : req.body.taxNumber
      };
      
      const validatedData = insertSupplierSchema.parse(cleanedData);
      const supplier = await storage.updateSupplier(id, validatedData);
      if (supplier) {
        res.json(supplier);
      } else {
        res.status(404).json({ message: "المورد غير موجود" });
      }
    } catch (error: any) {
      console.error("خطأ في تحديث المورد:", error);
      res.status(400).json({ message: "بيانات المورد غير صحيحة", error: error?.message || "خطأ غير معروف" });
    }
  });

  app.patch("/api/suppliers/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const data = req.body;
      
      console.log('بيانات المورد الواردة:', data);
      
      // تنظيف البيانات
      const cleanedData = {
        name: data.name,
        phone: data.phone || null,
        email: data.email || null,
        address: data.address || null,
        taxNumber: data.taxNumber || null,
        creditLimit: data.creditLimit || '0',
        balance: data.balance || '0'
      };
      
      console.log('البيانات بعد التحقق:', cleanedData);
      
      const updatedSupplier = await storage.updateSupplier(id, cleanedData);
      
      if (!updatedSupplier) {
        return res.status(404).json({ error: "Supplier not found" });
      }
      
      res.json(updatedSupplier);
    } catch (error) {
      console.error("Error updating supplier:", error);
      res.status(500).json({ error: "Failed to update supplier" });
    }
  });

  app.delete("/api/suppliers/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteSupplier(id);
      if (deleted) {
        res.json({ message: "Supplier deleted successfully" });
      } else {
        res.status(404).json({ message: "Supplier not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete supplier" });
    }
  });

  // Clients routes
  app.get("/api/clients", async (req, res) => {
    try {
      const clients = await storage.getAllClients();
      res.json(clients);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch clients" });
    }
  });

  app.post("/api/clients", async (req, res) => {
    try {
      console.log("البيانات الواردة:", req.body);
      
      // تنظيف وتجهيز البيانات
      const clientData = {
        name: req.body.name,
        phone: req.body.phone || null,
        email: req.body.email || null,
        address: req.body.address || null,
        group: req.body.group || 'عام',
        balance: String(req.body.openingBalance || 0),
        openingBalance: String(req.body.openingBalance || 0),
        currentBalance: String(req.body.openingBalance || 0),
        creditLimit: String(req.body.creditLimit || 0),
        accountType: req.body.accountType || 'cash',
        status: req.body.status || 'active'
      };
      
      console.log("البيانات بعد المعالجة:", clientData);
      
      const validatedData = insertClientSchema.parse(clientData);
      const client = await storage.createClient(validatedData);
      res.status(201).json(client);
    } catch (error: any) {
      console.error("خطأ في إضافة العميل:", error);
      res.status(400).json({ 
        message: "بيانات العميل غير صحيحة",
        error: error?.message,
        details: error?.issues || []
      });
    }
  });

  app.delete("/api/clients/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteClient(id);
      if (deleted) {
        res.json({ message: "Client deleted successfully" });
      } else {
        res.status(404).json({ message: "Client not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete client" });
    }
  });

  // Products routes
  app.get("/api/products", async (req, res) => {
    try {
      const products = await storage.getAllProducts();
      res.json(products);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });

  app.post("/api/products", async (req, res) => {
    try {
      const validatedData = insertProductSchema.parse(req.body);
      const product = await storage.createProduct(validatedData);
      res.status(201).json(product);
    } catch (error: any) {
      console.error("Product creation error:", error);
      
      // معالجة أخطاء قاعدة البيانات
      if (error?.code === '23505') {
        if (error.constraint === 'products_code_unique') {
          return res.status(400).json({ 
            message: "كود الصنف موجود بالفعل، يرجى استخدام كود آخر",
            field: "code"
          });
        }
        if (error.constraint === 'products_barcode_unique') {
          return res.status(400).json({ 
            message: "الباركود موجود بالفعل، يرجى استخدام باركود آخر",
            field: "barcode"
          });
        }
      }
      
      if (error instanceof Error) {
        res.status(400).json({ message: "بيانات الصنف غير صحيحة", error: error.message });
      } else {
        res.status(400).json({ message: "بيانات الصنف غير صحيحة" });
      }
    }
  });

  app.delete("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteProduct(id);
      if (deleted) {
        res.json({ message: "Product deleted successfully" });
      } else {
        res.status(404).json({ message: "Product not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete product" });
    }
  });

  // Sales routes
  app.get("/api/sales", async (req, res) => {
    try {
      const sales = await storage.getAllSales();
      res.json(sales);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch sales" });
    }
  });

  app.post("/api/sales", async (req, res) => {
    try {
      console.log("بيانات المبيعة المرسلة:", JSON.stringify(req.body, null, 2));
      
      const insertSaleSchemaLocal = z.object({
        clientId: z.number().optional(),
        total: z.union([z.string(), z.number()]).transform(val => String(val)),
        branchId: z.number().optional(),
        items: z.array(z.object({
          productId: z.number(),
          quantity: z.number(),
          unitPrice: z.number(),
          total: z.number(),
          productName: z.string().optional(),
        })).optional(),
        notes: z.string().optional(),
      });
      
      const validatedData = insertSaleSchemaLocal.parse(req.body);
      
      // إنشاء فاتورة المبيعات
      const sale = await storage.createSale(validatedData);
      
      // تحديث رصيد العميل تلقائياً (زيادة الدين)
      if (validatedData.clientId && validatedData.total) {
        try {
          const totalAmount = parseFloat(validatedData.total);
          await storage.updateClientBalance(validatedData.clientId, totalAmount, 'increase');
          console.log(`تم تحديث رصيد العميل ${validatedData.clientId} بإضافة ${totalAmount} ر.س للفاتورة ${sale.id}`);
        } catch (error) {
          console.error(`خطأ في تحديث رصيد العميل ${validatedData.clientId}:`, error);
        }
      }
      
      // تحديث المخزون تلقائياً عند البيع
      if (validatedData.items && Array.isArray(validatedData.items)) {
        for (const item of validatedData.items) {
          if (item.productId && item.quantity) {
            try {
              await storage.processInventoryTransaction(
                item.productId, 
                item.quantity, 
                'sale'
              );
              console.log(`تم خصم ${item.quantity} قطعة من المنتج ${item.productId} للفاتورة ${sale.id}`);
            } catch (error) {
              console.error(`خطأ في تحديث المخزون للمنتج ${item.productId}:`, error);
            }
          }
        }
      }
      
      res.status(201).json(sale);
    } catch (error) {
      console.error("خطأ في إنشاء فاتورة المبيعات:", error);
      res.status(400).json({ message: "Invalid sale data", error: error.message });
    }
  });

  app.delete("/api/sales/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteSale(id);
      if (deleted) {
        res.json({ message: "Sale deleted successfully" });
      } else {
        res.status(404).json({ message: "Sale not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete sale" });
    }
  });

  // Purchases routes
  app.get("/api/purchases", async (req, res) => {
    try {
      const purchases = await storage.getAllPurchases();
      res.json(purchases);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch purchases" });
    }
  });

  app.post("/api/purchases", async (req, res) => {
    try {
      const validatedData = insertPurchaseSchema.parse(req.body);
      
      // إنشاء فاتورة المشتريات
      const purchase = await storage.createPurchase(validatedData);
      
      // تحديث رصيد المورد تلقائياً (زيادة الدين)
      if (validatedData.supplierId && validatedData.total) {
        try {
          const totalAmount = parseFloat(validatedData.total);
          await storage.updateSupplierBalance(validatedData.supplierId, totalAmount, 'increase');
          console.log(`تم تحديث رصيد المورد ${validatedData.supplierId} بإضافة ${totalAmount} ر.س للفاتورة ${purchase.id}`);
        } catch (error) {
          console.error(`خطأ في تحديث رصيد المورد ${validatedData.supplierId}:`, error);
        }
      }
      
      // تحديث المخزون تلقائياً عند الشراء
      if (validatedData.items && Array.isArray(validatedData.items)) {
        for (const item of validatedData.items) {
          if (item.productId && item.quantity) {
            try {
              await storage.processInventoryTransaction(
                item.productId, 
                item.quantity, 
                'purchase'
              );
              console.log(`تم إضافة ${item.quantity} قطعة للمنتج ${item.productId} للفاتورة ${purchase.id}`);
            } catch (error) {
              console.error(`خطأ في تحديث المخزون للمنتج ${item.productId}:`, error);
            }
          }
        }
      }
      
      res.status(201).json(purchase);
    } catch (error) {
      console.error("خطأ في إنشاء فاتورة المشتريات:", error);
      res.status(400).json({ message: "Invalid purchase data" });
    }
  });

  // Get single product
  app.get("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const product = await storage.getProduct(id);
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      res.json(product);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch product" });
    }
  });

  // Auto-register product
  app.post("/api/products/auto-register", async (req, res) => {
    try {
      const productData = req.body;
      const product = await storage.autoRegisterProduct(productData);
      res.status(201).json(product);
    } catch (error) {
      console.error("خطأ في التسجيل التلقائي للمنتج:", error);
      res.status(500).json({ message: "Failed to auto-register product" });
    }
  });

  // Update product (including inventory adjustments)
  app.patch("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      const product = await storage.updateProduct(id, updateData);
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      res.json(product);
    } catch (error) {
      res.status(400).json({ message: "Failed to update product" });
    }
  });

  // Update product with full replacement
  app.put("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertProductSchema.parse(req.body);
      const product = await storage.updateProduct(id, validatedData);
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      res.json(product);
    } catch (error) {
      res.status(400).json({ message: "Failed to update product" });
    }
  });

  // Employees routes
  app.get("/api/employees", async (req, res) => {
    try {
      const employees = await storage.getAllEmployees();
      res.json(employees);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch employees" });
    }
  });

  app.post("/api/employees", async (req, res) => {
    try {
      console.log("Received employee data:", req.body);
      const validatedData = insertEmployeeSchema.parse(req.body);
      console.log("Validated employee data:", validatedData);
      const employee = await storage.createEmployee(validatedData);
      res.status(201).json(employee);
    } catch (error) {
      console.log("Error creating employee:", error);
      if (error instanceof Error) {
        res.status(400).json({ message: error.message });
      } else {
        res.status(400).json({ message: "Invalid employee data" });
      }
    }
  });

  app.put("/api/employees/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log("Updating employee ID:", id, "with data:", req.body);
      const validatedData = insertEmployeeSchema.parse(req.body);
      console.log("Validated update data:", validatedData);
      const employee = await storage.updateEmployee(id, validatedData);
      res.json(employee);
    } catch (error) {
      console.log("Error updating employee:", error);
      if (error instanceof Error) {
        res.status(400).json({ message: error.message });
      } else {
        res.status(400).json({ message: "Invalid employee data" });
      }
    }
  });

  app.patch("/api/employees/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      const employee = await storage.updateEmployee(id, updateData);
      if (!employee) {
        return res.status(404).json({ message: "Employee not found" });
      }
      res.json(employee);
    } catch (error) {
      res.status(400).json({ message: "Failed to update employee" });
    }
  });

  app.delete("/api/employees/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteEmployee(id);
      if (deleted) {
        res.json({ message: "Employee deleted successfully" });
      } else {
        res.status(404).json({ message: "Employee not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete employee" });
    }
  });

  // Deductions routes
  app.get("/api/deductions", async (req, res) => {
    try {
      const deductions = await storage.getAllDeductions();
      res.json(deductions);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch deductions" });
    }
  });

  app.post("/api/deductions", async (req, res) => {
    try {
      console.log("بيانات الخصم المستلمة:", req.body);
      
      // مخطط محدد للتحقق من بيانات الخصم مع تحويل التاريخ
      const deductionSchema = z.object({
        employeeId: z.number(),
        type: z.string(),
        amount: z.string(),
        description: z.string().optional(),
        date: z.string().transform(val => new Date(val)),
        recurring: z.boolean().optional().default(false)
      });
      
      const validatedData = deductionSchema.parse(req.body);
      console.log("بيانات الخصم بعد التحقق:", validatedData);
      const deduction = await storage.createDeduction(validatedData);
      res.status(201).json(deduction);
    } catch (error) {
      console.error("خطأ في إنشاء الخصم:", error);
      res.status(400).json({ message: "Invalid deduction data", error: error.message });
    }
  });

  app.patch("/api/deductions/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      const deduction = await storage.updateDeduction(id, updateData);
      if (!deduction) {
        return res.status(404).json({ message: "Deduction not found" });
      }
      res.json(deduction);
    } catch (error) {
      res.status(400).json({ message: "Failed to update deduction" });
    }
  });

  app.delete("/api/deductions/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteDeduction(id);
      if (deleted) {
        res.json({ message: "Deduction deleted successfully" });
      } else {
        res.status(404).json({ message: "Deduction not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete deduction" });
    }
  });

  // Salaries routes
  app.get("/api/salaries", async (req, res) => {
    try {
      const salaries = await storage.getAllSalaries();
      res.json(salaries);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch salaries" });
    }
  });

  app.post("/api/salaries", async (req, res) => {
    try {
      console.log("بيانات الراتب الواردة:", req.body);
      const validatedData = insertSalarySchema.parse(req.body);
      console.log("بيانات الراتب بعد التحقق:", validatedData);
      const salary = await storage.createSalary(validatedData);
      res.status(201).json(salary);
    } catch (error) {
      console.error("خطأ في إنشاء الراتب:", error);
      res.status(400).json({ message: "Invalid salary data", error: error.message });
    }
  });

  app.patch("/api/salaries/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      const salary = await storage.updateSalary(id, updateData);
      if (!salary) {
        return res.status(404).json({ message: "Salary not found" });
      }
      res.json(salary);
    } catch (error) {
      res.status(400).json({ message: "Failed to update salary" });
    }
  });

  app.delete("/api/salaries/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteSalary(id);
      if (deleted) {
        res.json({ message: "Salary deleted successfully" });
      } else {
        res.status(404).json({ message: "Salary not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete salary" });
    }
  });

  // Product Categories routes
  app.get("/api/product-categories", async (req, res) => {
    try {
      const categories = await storage.getAllProductCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching product categories:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/product-categories", async (req, res) => {
    try {
      const categoryData = insertProductCategorySchema.parse(req.body);
      const category = await storage.createProductCategory(categoryData);
      res.status(201).json(category);
    } catch (error) {
      console.error("Error creating product category:", error);
      res.status(400).json({ message: "Invalid category data" });
    }
  });

  app.put("/api/product-categories/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = insertProductCategorySchema.partial().parse(req.body);
      const category = await storage.updateProductCategory(id, updateData);
      
      if (!category) {
        return res.status(404).json({ message: "Category not found" });
      }
      
      res.json(category);
    } catch (error) {
      console.error("Error updating product category:", error);
      res.status(400).json({ message: "Invalid category data" });
    }
  });

  app.delete("/api/product-categories/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteProductCategory(id);
      
      if (!success) {
        return res.status(404).json({ message: "Category not found" });
      }
      
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting product category:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Quotes routes
  app.get('/api/quotes', async (req, res) => {
    try {
      const quotes = await storage.getAllQuotes();
      res.json(quotes);
    } catch (error) {
      console.error('Error fetching quotes:', error);
      res.status(500).json({ error: 'Failed to fetch quotes' });
    }
  });

  app.post('/api/quotes', async (req, res) => {
    try {
      const insertQuoteSchema = z.object({
        clientId: z.number().optional(),
        quoteNumber: z.string(),
        total: z.string(),
        tax: z.string().optional(),
        discount: z.string().optional(),
        status: z.string().optional(),
        validUntil: z.string(),
        notes: z.string().optional(),
        items: z.any().optional(),
      });
      
      const validatedData = insertQuoteSchema.parse(req.body);
      const quote = await storage.createQuote({
        ...validatedData,
        validUntil: new Date(validatedData.validUntil),
      });
      
      res.status(201).json(quote);
    } catch (error) {
      console.error('Error creating quote:', error);
      res.status(500).json({ error: 'Failed to create quote' });
    }
  });

  app.put('/api/quotes/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      
      if (updateData.validUntil) {
        updateData.validUntil = new Date(updateData.validUntil);
      }
      
      const quote = await storage.updateQuote(id, updateData);
      
      if (!quote) {
        return res.status(404).json({ error: 'Quote not found' });
      }
      
      res.json(quote);
    } catch (error) {
      console.error('Error updating quote:', error);
      res.status(500).json({ error: 'Failed to update quote' });
    }
  });

  app.delete('/api/quotes/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteQuote(id);
      
      if (!deleted) {
        return res.status(404).json({ error: 'Quote not found' });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting quote:', error);
      res.status(500).json({ error: 'Failed to delete quote' });
    }
  });

  // Sales Returns routes
  app.get('/api/sales-returns', async (req, res) => {
    try {
      const salesReturns = await storage.getAllSalesReturns();
      res.json(salesReturns);
    } catch (error) {
      console.error('Error fetching sales returns:', error);
      res.status(500).json({ error: 'Failed to fetch sales returns' });
    }
  });

  app.post('/api/sales-returns', async (req, res) => {
    try {
      const insertSalesReturnSchema = z.object({
        saleId: z.number().optional(),
        returnNumber: z.string(),
        total: z.string(),
        reason: z.string(),
        status: z.string().optional(),
        notes: z.string().optional(),
        items: z.any().optional(),
      });
      
      const validatedData = insertSalesReturnSchema.parse(req.body);
      
      // إنشاء سند الإخراج
      const salesReturn = await storage.createSalesReturn(validatedData);
      
      // إذا كان مرتبط بفاتورة مبيعات، قم بخصم المبلغ وإرجاع الكمية للمخزن
      if (validatedData.saleId && validatedData.items) {
        // جلب الفاتورة الأصلية
        const originalSale = await storage.getSale(validatedData.saleId);
        if (originalSale) {
          // خصم مبلغ المرتجع من إجمالي الفاتورة
          const originalTotal = parseFloat(originalSale.total);
          const returnAmount = parseFloat(validatedData.total);
          const newTotal = Math.max(0, originalTotal - returnAmount);
          
          await storage.updateSale(validatedData.saleId, {
            total: newTotal.toFixed(2)
          });
          
          console.log(`تم خصم ${returnAmount} من فاتورة المبيعات رقم ${validatedData.saleId}`);
          
          // إرجاع الكميات للمخزن
          for (const item of validatedData.items) {
            if (item.productId && item.quantity) {
              const product = await storage.getProduct(item.productId);
              if (product) {
                const currentStock = parseInt(product.quantity?.toString() || '0') || 0;
                const returnQuantity = parseInt(item.quantity) || 0;
                const newStock = currentStock + returnQuantity;
                
                await storage.updateProduct(item.productId, {
                  quantity: newStock
                });
                
                console.log(`تم إرجاع ${returnQuantity} قطعة من المنتج ${product.name} للمخزن. الكمية الجديدة: ${newStock}`);
              }
            }
          }
        }
      }
      
      res.status(201).json(salesReturn);
    } catch (error) {
      console.error('Error creating sales return:', error);
      res.status(500).json({ error: 'Failed to create sales return' });
    }
  });

  app.put('/api/sales-returns/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      
      const salesReturn = await storage.updateSalesReturn(id, updateData);
      
      if (!salesReturn) {
        return res.status(404).json({ error: 'Sales return not found' });
      }
      
      res.json(salesReturn);
    } catch (error) {
      console.error('Error updating sales return:', error);
      res.status(500).json({ error: 'Failed to update sales return' });
    }
  });

  app.patch('/api/sales-returns/:id/status', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status } = req.body;
      
      if (!status || !['approved', 'pending', 'rejected'].includes(status)) {
        return res.status(400).json({ error: 'Invalid status. Must be: approved, pending, or rejected' });
      }
      
      const salesReturn = await storage.updateSalesReturn(id, { status });
      
      if (!salesReturn) {
        return res.status(404).json({ error: 'Sales return not found' });
      }
      
      console.log(`تم تحديث حالة مرتجع المبيعات رقم ${id} إلى: ${status}`);
      res.json(salesReturn);
    } catch (error) {
      console.error('Error updating sales return status:', error);
      res.status(500).json({ error: 'Failed to update sales return status' });
    }
  });

  app.delete('/api/sales-returns/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteSalesReturn(id);
      
      if (!deleted) {
        return res.status(404).json({ error: 'Sales return not found' });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting sales return:', error);
      res.status(500).json({ error: 'Failed to delete sales return' });
    }
  });

  // Purchase Returns routes
  app.get('/api/purchase-returns', async (req, res) => {
    try {
      const purchaseReturns = await storage.getAllPurchaseReturns();
      res.json(purchaseReturns);
    } catch (error) {
      console.error('Error fetching purchase returns:', error);
      res.status(500).json({ error: 'Failed to fetch purchase returns' });
    }
  });

  app.post('/api/purchase-returns', async (req, res) => {
    try {
      const insertPurchaseReturnSchema = z.object({
        purchaseId: z.number().optional(),
        returnNumber: z.string(),
        total: z.string(),
        reason: z.string(),
        status: z.string().optional(),
        notes: z.string().optional(),
        items: z.any().optional(),
      });
      
      const validatedData = insertPurchaseReturnSchema.parse(req.body);
      
      // إنشاء المرتجع
      const purchaseReturn = await storage.createPurchaseReturn(validatedData);
      
      // إذا كان المرتجع مرتبط بفاتورة محددة، قم بخصم المبلغ من الفاتورة الأصلية
      if (validatedData.purchaseId) {
        const originalPurchase = await storage.getPurchase(validatedData.purchaseId);
        if (originalPurchase) {
          const originalTotal = parseFloat(originalPurchase.total);
          const returnAmount = parseFloat(validatedData.total);
          const newTotal = Math.max(0, originalTotal - returnAmount);
          
          await storage.updatePurchase(validatedData.purchaseId, {
            total: newTotal.toFixed(2)
          });
          
          console.log(`تم خصم ${returnAmount} من فاتورة المشتريات رقم ${validatedData.purchaseId}. المبلغ الجديد: ${newTotal}`);
        }
      }

      // تحديث المخزون تلقائياً عند مرتجعات المشتريات
      if (validatedData.items && Array.isArray(validatedData.items)) {
        for (const item of validatedData.items) {
          if (item.productId && item.quantity) {
            try {
              // خصم الكمية من المخزون مباشرة
              const product = await storage.getProduct(item.productId);
              if (product) {
                const currentQuantity = parseInt(product.quantity?.toString() || '0') || 0;
                const newQuantity = Math.max(0, currentQuantity - item.quantity);
                await storage.updateProduct(item.productId, { quantity: newQuantity });
                console.log(`تم خصم ${item.quantity} قطعة من المنتج ${item.productId} - الكمية السابقة: ${currentQuantity}, الكمية الجديدة: ${newQuantity}`);
              }
            } catch (error) {
              console.error(`خطأ في تحديث المخزون للمنتج ${item.productId}:`, error);
            }
          }
        }
      }
      
      res.status(201).json(purchaseReturn);
    } catch (error) {
      console.error('Error creating purchase return:', error);
      res.status(500).json({ error: 'Failed to create purchase return' });
    }
  });

  app.put('/api/purchase-returns/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      
      // الحصول على المرتجع الحالي قبل التحديث
      const currentReturn = await storage.getPurchaseReturn(id);
      if (!currentReturn) {
        return res.status(404).json({ error: 'Purchase return not found' });
      }
      
      const purchaseReturn = await storage.updatePurchaseReturn(id, updateData);
      
      // إذا تم تغيير حالة المرتجع إلى معتمد وكان مرتبط بفاتورة
      if (updateData.status === 'approved' && currentReturn.status !== 'approved' && currentReturn.purchaseId) {
        const originalPurchase = await storage.getPurchase(currentReturn.purchaseId);
        if (originalPurchase) {
          const originalTotal = parseFloat(originalPurchase.total);
          const returnAmount = parseFloat(currentReturn.total);
          const newTotal = Math.max(0, originalTotal - returnAmount);
          
          await storage.updatePurchase(currentReturn.purchaseId, {
            total: newTotal.toFixed(2)
          });
          
          console.log(`تم اعتماد المرتجع وخصم ${returnAmount} من فاتورة المشتريات رقم ${currentReturn.purchaseId}`);
        }
      }
      
      res.json(purchaseReturn);
    } catch (error) {
      console.error('Error updating purchase return:', error);
      res.status(500).json({ error: 'Failed to update purchase return' });
    }
  });

  app.patch('/api/purchase-returns/:id/status', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status } = req.body;
      
      if (!status || !['approved', 'pending', 'rejected'].includes(status)) {
        return res.status(400).json({ error: 'Invalid status. Must be: approved, pending, or rejected' });
      }
      
      const purchaseReturn = await storage.updatePurchaseReturn(id, { status });
      
      if (!purchaseReturn) {
        return res.status(404).json({ error: 'Purchase return not found' });
      }
      
      console.log(`تم تحديث حالة مرتجع المشتريات رقم ${id} إلى: ${status}`);
      res.json(purchaseReturn);
    } catch (error) {
      console.error('Error updating purchase return status:', error);
      res.status(500).json({ error: 'Failed to update purchase return status' });
    }
  });

  app.delete('/api/purchase-returns/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deletePurchaseReturn(id);
      
      if (!deleted) {
        return res.status(404).json({ error: 'Purchase return not found' });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting purchase return:', error);
      res.status(500).json({ error: 'Failed to delete purchase return' });
    }
  });

  // Purchase Orders routes
  app.get('/api/purchase-orders', async (req, res) => {
    try {
      const purchaseOrders = await storage.getAllPurchaseOrders();
      res.json(purchaseOrders);
    } catch (error) {
      console.error('Error fetching purchase orders:', error);
      res.status(500).json({ error: 'Failed to fetch purchase orders' });
    }
  });

  app.post('/api/purchase-orders', async (req, res) => {
    try {
      const insertPurchaseOrderSchema = z.object({
        orderNumber: z.string(),
        supplierId: z.number().optional(),
        supplierName: z.string().optional(),
        total: z.string().optional(),
        status: z.string().optional(),
        requestedBy: z.string().optional(),
        notes: z.string().optional(),
        items: z.any().optional(),
      });
      
      const validatedData = insertPurchaseOrderSchema.parse(req.body);
      const purchaseOrder = await storage.createPurchaseOrder(validatedData);
      res.status(201).json(purchaseOrder);
    } catch (error) {
      console.error('Error creating purchase order:', error);
      res.status(500).json({ error: 'Failed to create purchase order' });
    }
  });

  app.put('/api/purchase-orders/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      
      const purchaseOrder = await storage.updatePurchaseOrder(id, updateData);
      
      if (!purchaseOrder) {
        return res.status(404).json({ error: 'Purchase order not found' });
      }
      
      res.json(purchaseOrder);
    } catch (error) {
      console.error('Error updating purchase order:', error);
      res.status(500).json({ error: 'Failed to update purchase order' });
    }
  });

  app.delete('/api/purchase-orders/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deletePurchaseOrder(id);
      
      if (!deleted) {
        return res.status(404).json({ error: 'Purchase order not found' });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting purchase order:', error);
      res.status(500).json({ error: 'Failed to delete purchase order' });
    }
  });

  // Goods Receipt Vouchers routes
  app.get('/api/goods-receipt-vouchers', async (req, res) => {
    try {
      const vouchers = await storage.getAllGoodsReceiptVouchers();
      res.json(vouchers);
    } catch (error) {
      console.error('Error fetching goods receipt vouchers:', error);
      res.status(500).json({ error: 'Failed to fetch goods receipt vouchers' });
    }
  });

  app.post('/api/goods-receipt-vouchers', async (req, res) => {
    try {
      // تحويل التاريخ للتنسيق الصحيح
      const data = req.body;
      if (data.receivedDate && typeof data.receivedDate === 'string') {
        data.receivedDate = new Date(data.receivedDate);
      }
      
      const validatedData = data;
      const voucher = await storage.createGoodsReceiptVoucher(validatedData);
      res.status(201).json(voucher);
    } catch (error) {
      console.error('Error creating goods receipt voucher:', error);
      res.status(500).json({ error: 'Failed to create goods receipt voucher' });
    }
  });

  app.put('/api/goods-receipt-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      
      const voucher = await storage.updateGoodsReceiptVoucher(id, updateData);
      
      if (!voucher) {
        return res.status(404).json({ error: 'Goods receipt voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error updating goods receipt voucher:', error);
      res.status(500).json({ error: 'Failed to update goods receipt voucher' });
    }
  });

  app.delete('/api/goods-receipt-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteGoodsReceiptVoucher(id);
      
      if (!deleted) {
        return res.status(404).json({ error: 'Goods receipt voucher not found' });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting goods receipt voucher:', error);
      res.status(500).json({ error: 'Failed to delete goods receipt voucher' });
    }
  });

  // Supplier Payment Vouchers routes
  app.get('/api/supplier-payment-vouchers', async (req, res) => {
    try {
      const vouchers = await storage.getAllSupplierPaymentVouchers();
      res.json(vouchers);
    } catch (error) {
      console.error('Error fetching supplier payment vouchers:', error);
      res.status(500).json({ error: 'Failed to fetch supplier payment vouchers' });
    }
  });

  app.get('/api/supplier-payment-vouchers/supplier/:supplierId', async (req, res) => {
    try {
      const supplierId = parseInt(req.params.supplierId);
      const vouchers = await storage.getSupplierPaymentVouchersBySupplierId(supplierId);
      res.json(vouchers);
    } catch (error) {
      console.error('Error fetching supplier payment vouchers:', error);
      res.status(500).json({ error: 'Failed to fetch supplier payment vouchers' });
    }
  });

  app.post('/api/supplier-payment-vouchers', async (req, res) => {
    try {
      const validatedData = insertSupplierPaymentVoucherSchema.parse(req.body);
      
      // إنشاء سند الصرف
      const voucher = await storage.createSupplierPaymentVoucher(validatedData);
      
      // لا نخصم من الرصيد الافتتاحي هنا - الحساب يتم في GET /api/suppliers
      console.log(`تم إضافة سند صرف بقيمة ${validatedData.amount} للمورد ${validatedData.supplierId}`);
      
      res.status(201).json(voucher);
    } catch (error) {
      console.error('Error creating supplier payment voucher:', error);
      res.status(500).json({ error: 'Failed to create supplier payment voucher' });
    }
  });

  app.put('/api/supplier-payment-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      
      const voucher = await storage.updateSupplierPaymentVoucher(id, updateData);
      
      if (!voucher) {
        return res.status(404).json({ error: 'Supplier payment voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error updating supplier payment voucher:', error);
      res.status(500).json({ error: 'Failed to update supplier payment voucher' });
    }
  });

  app.delete('/api/supplier-payment-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const success = await storage.deleteSupplierPaymentVoucher(id);
      
      if (!success) {
        return res.status(404).json({ error: 'Supplier payment voucher not found' });
      }
      
      console.log(`تم حذف سند الصرف رقم ${id} - الرصيد الحالي سيتحدث تلقائياً`);
      
      res.json({ message: 'Supplier payment voucher deleted successfully' });
    } catch (error) {
      console.error('Error deleting supplier payment voucher:', error);
      res.status(500).json({ error: 'Failed to delete supplier payment voucher' });
    }
  });

  // Client Receipt Vouchers routes
  app.get('/api/client-receipt-vouchers', async (req, res) => {
    try {
      const vouchers = await storage.getAllClientReceiptVouchers();
      res.json(vouchers);
    } catch (error) {
      console.error('Error fetching client receipt vouchers:', error);
      res.status(500).json({ error: 'Failed to fetch client receipt vouchers' });
    }
  });

  app.get('/api/client-receipt-vouchers/client/:clientId', async (req, res) => {
    try {
      const clientId = parseInt(req.params.clientId);
      const vouchers = await storage.getClientReceiptVouchersByClientId(clientId);
      res.json(vouchers);
    } catch (error) {
      console.error('Error fetching client receipt vouchers:', error);
      res.status(500).json({ error: 'Failed to fetch client receipt vouchers' });
    }
  });

  app.post('/api/client-receipt-vouchers', async (req, res) => {
    try {
      console.log("البيانات الواردة لسند القبض:", req.body);
      
      // تنظيف وتجهيز البيانات
      const voucherData = {
        ...req.body,
        amount: String(req.body.amount || 0),
        receiptDate: req.body.receiptDate || new Date().toISOString().split('T')[0],
        paymentMethod: req.body.paymentMethod || 'نقدي',
        status: req.body.status || 'مؤكد'
      };
      
      console.log("البيانات بعد المعالجة:", voucherData);
      
      const validatedData = insertClientReceiptVoucherSchema.parse(voucherData);
      
      // إنشاء سند القبض
      const voucher = await storage.createClientReceiptVoucher(validatedData);
      
      // إضافة المبلغ إلى رصيد العميل (تقليل الدين)
      const client = await storage.getClient(validatedData.clientId);
      if (client) {
        const currentBalance = parseFloat(client.balance || '0') || 0;
        const voucherAmount = parseFloat(validatedData.amount);
        const newBalance = (currentBalance - voucherAmount).toString();
        
        await storage.updateClient(validatedData.clientId, {
          balance: newBalance
        });
        
        console.log(`تم خصم ${voucherAmount} من دين العميل ${client.name}. الرصيد الجديد: ${newBalance}`);
      }
      
      res.status(201).json(voucher);
    } catch (error: any) {
      console.error('خطأ في إنشاء سند القبض:', error);
      res.status(500).json({ 
        error: "فشل في إنشاء سند القبض",
        message: error?.message,
        details: error?.issues || []
      });
    }
  });

  app.put('/api/client-receipt-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertClientReceiptVoucherSchema.partial().parse(req.body);
      
      const voucher = await storage.updateClientReceiptVoucher(id, validatedData);
      
      if (!voucher) {
        return res.status(404).json({ error: 'Client receipt voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error updating client receipt voucher:', error);
      res.status(500).json({ error: 'Failed to update client receipt voucher' });
    }
  });

  app.delete('/api/client-receipt-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // الحصول على بيانات السند قبل الحذف لإعادة المبلغ للرصيد
      const voucher = await storage.getClientReceiptVoucher(id);
      if (!voucher) {
        return res.status(404).json({ error: 'Client receipt voucher not found' });
      }
      
      const success = await storage.deleteClientReceiptVoucher(id);
      if (!success) {
        return res.status(404).json({ error: 'Client receipt voucher not found' });
      }
      
      // إعادة المبلغ إلى دين العميل
      const client = await storage.getClient(voucher.clientId);
      if (client) {
        const currentBalance = parseFloat(client.balance || '0') || 0;
        const voucherAmount = parseFloat(voucher.amount);
        const newBalance = (currentBalance + voucherAmount).toString();
        
        await storage.updateClient(voucher.clientId, {
          balance: newBalance
        });
        
        console.log(`تم إعادة ${voucherAmount} إلى دين العميل ${client.name}. الرصيد الجديد: ${newBalance}`);
      }
      
      res.json({ message: 'Client receipt voucher deleted successfully' });
    } catch (error) {
      console.error('Error deleting client receipt voucher:', error);
      res.status(500).json({ error: 'Failed to delete client receipt voucher' });
    }
  });

  // Inventory Opening Balances routes
  app.get('/api/inventory-opening-balances', async (req, res) => {
    try {
      const balances = await storage.getAllInventoryOpeningBalances();
      res.json(balances);
    } catch (error) {
      console.error('Error fetching inventory opening balances:', error);
      res.status(500).json({ error: 'Failed to fetch inventory opening balances' });
    }
  });

  app.get('/api/inventory-opening-balances/product/:productId', async (req, res) => {
    try {
      const productId = parseInt(req.params.productId);
      const balance = await storage.getInventoryOpeningBalanceByProductId(productId);
      res.json(balance);
    } catch (error) {
      console.error('Error fetching inventory opening balance:', error);
      res.status(500).json({ error: 'Failed to fetch inventory opening balance' });
    }
  });

  app.post('/api/inventory-opening-balances', async (req, res) => {
    try {
      const validatedData = insertInventoryOpeningBalanceSchema.parse(req.body);
      
      // التحقق من وجود رصيد افتتاحي مسبق للمنتج
      const existingBalance = await storage.getInventoryOpeningBalanceByProductId(validatedData.productId);
      if (existingBalance) {
        return res.status(400).json({ error: 'يوجد رصيد افتتاحي مسجل لهذا المنتج مسبقاً' });
      }
      
      const balance = await storage.createInventoryOpeningBalance(validatedData);
      res.status(201).json(balance);
    } catch (error) {
      console.error('Error creating inventory opening balance:', error);
      res.status(500).json({ error: 'Failed to create inventory opening balance' });
    }
  });

  app.put('/api/inventory-opening-balances/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertInventoryOpeningBalanceSchema.partial().parse(req.body);
      
      const balance = await storage.updateInventoryOpeningBalance(id, validatedData);
      
      if (!balance) {
        return res.status(404).json({ error: 'Inventory opening balance not found' });
      }
      
      res.json(balance);
    } catch (error) {
      console.error('Error updating inventory opening balance:', error);
      res.status(500).json({ error: 'Failed to update inventory opening balance' });
    }
  });

  app.delete('/api/inventory-opening-balances/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const success = await storage.deleteInventoryOpeningBalance(id);
      if (!success) {
        return res.status(404).json({ error: 'Inventory opening balance not found' });
      }
      
      res.json({ message: 'Inventory opening balance deleted successfully' });
    } catch (error) {
      console.error('Error deleting inventory opening balance:', error);
      res.status(500).json({ error: 'Failed to delete inventory opening balance' });
    }
  });

  // Suppliers Excel Import
  app.post('/api/suppliers/import-excel', excelUpload.single('excel'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'لا يوجد ملف Excel مرفق' });
      }

      const filePath = req.file.path;
      
      // قراءة ملف Excel
      const workbook = XLSX.readFile(filePath);
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // تحويل البيانات إلى JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      
      if (jsonData.length === 0) {
        return res.status(400).json({ error: 'الملف فارغ أو لا يحتوي على بيانات صالحة' });
      }

      const results = {
        total: jsonData.length,
        success: 0,
        failed: 0,
        errors: [] as string[]
      };

      // معالجة كل صف في ملف Excel
      for (let i = 0; i < jsonData.length; i++) {
        const row = jsonData[i] as any;
        
        try {
          // استخراج البيانات من الصف
          const supplierData = {
            name: row['اسم المورد'] || row['name'] || row['Name'] || row['المورد'],
            phone: row['الهاتف'] || row['phone'] || row['Phone'] || row['رقم الهاتف'] || '',
            email: row['البريد الإلكتروني'] || row['email'] || row['Email'] || '',
            address: row['العنوان'] || row['address'] || row['Address'] || '',
            taxNumber: row['الرقم الضريبي'] || row['taxNumber'] || row['Tax Number'] || '',
            contactPerson: row['الشخص المسؤول'] || row['contactPerson'] || row['Contact Person'] || '',
            notes: row['ملاحظات'] || row['notes'] || row['Notes'] || ''
          };

          // التحقق من البيانات المطلوبة
          if (!supplierData.name) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: اسم المورد مطلوب`);
            continue;
          }

          // التحقق من عدم وجود مورد بنفس الاسم
          const existingSuppliers = await storage.getAllSuppliers();
          const duplicateName = existingSuppliers.find(s => s.name === supplierData.name);
          
          if (duplicateName) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: المورد "${supplierData.name}" موجود مسبقاً`);
            continue;
          }

          // إنشاء المورد
          await storage.createSupplier(supplierData);
          results.success++;
          
        } catch (error) {
          results.failed++;
          (results.errors as string[]).push(`الصف ${i + 1}: ${error instanceof Error ? error.message : 'خطأ غير معروف'}`);
        }
      }

      // حذف الملف المؤقت
      try {
        fs.unlinkSync(filePath);
      } catch (error) {
        console.error('Error deleting temporary file:', error);
      }

      res.json({
        message: `تم استيراد ${results.success} مورد من أصل ${results.total}`,
        results
      });

    } catch (error) {
      console.error('Error importing suppliers from Excel:', error);
      
      // حذف الملف المؤقت في حالة الخطأ
      if (req.file) {
        try {
          fs.unlinkSync(req.file.path);
        } catch (unlinkError) {
          console.error('Error deleting temporary file after error:', unlinkError);
        }
      }
      
      res.status(500).json({ 
        error: 'حدث خطأ أثناء استيراد الموردين من ملف Excel',
        details: error instanceof Error ? error.message : 'خطأ غير معروف'
      });
    }
  });

  // Clients Excel Import
  app.post('/api/clients/import-excel', excelUpload.single('excel'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'لا يوجد ملف Excel مرفق' });
      }

      const filePath = req.file.path;
      
      // قراءة ملف Excel
      const workbook = XLSX.readFile(filePath);
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // تحويل البيانات إلى JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      
      if (jsonData.length === 0) {
        return res.status(400).json({ error: 'الملف فارغ أو لا يحتوي على بيانات صالحة' });
      }

      const results = {
        total: jsonData.length,
        success: 0,
        failed: 0,
        errors: [] as string[]
      };

      // معالجة كل صف في ملف Excel
      for (let i = 0; i < jsonData.length; i++) {
        const row = jsonData[i] as any;
        
        try {
          // استخراج البيانات من الصف
          const clientData = {
            name: row['اسم العميل'] || row['name'] || row['Name'] || row['العميل'],
            phone: row['الهاتف'] || row['phone'] || row['Phone'] || row['رقم الهاتف'] || '',
            email: row['البريد الإلكتروني'] || row['email'] || row['Email'] || '',
            address: row['العنوان'] || row['address'] || row['Address'] || '',
            taxNumber: row['الرقم الضريبي'] || row['taxNumber'] || row['Tax Number'] || '',
            notes: row['ملاحظات'] || row['notes'] || row['Notes'] || ''
          };

          // التحقق من البيانات المطلوبة
          if (!clientData.name) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: اسم العميل مطلوب`);
            continue;
          }

          // التحقق من عدم وجود عميل بنفس الاسم
          const existingClients = await storage.getAllClients();
          const duplicateName = existingClients.find(c => c.name === clientData.name);
          
          if (duplicateName) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: العميل "${clientData.name}" موجود مسبقاً`);
            continue;
          }

          // إنشاء العميل
          await storage.createClient(clientData);
          results.success++;
          
        } catch (error) {
          results.failed++;
          (results.errors as string[]).push(`الصف ${i + 1}: ${error instanceof Error ? error.message : 'خطأ غير معروف'}`);
        }
      }

      // حذف الملف المؤقت
      try {
        fs.unlinkSync(filePath);
      } catch (error) {
        console.error('Error deleting temporary file:', error);
      }

      res.json({
        message: `تم استيراد ${results.success} عميل من أصل ${results.total}`,
        results
      });

    } catch (error) {
      console.error('Error importing clients from Excel:', error);
      
      // حذف الملف المؤقت في حالة الخطأ
      if (req.file) {
        try {
          fs.unlinkSync(req.file.path);
        } catch (unlinkError) {
          console.error('Error deleting temporary file after error:', unlinkError);
        }
      }
      
      res.status(500).json({ 
        error: 'حدث خطأ أثناء استيراد العملاء من ملف Excel',
        details: error instanceof Error ? error.message : 'خطأ غير معروف'
      });
    }
  });

  // Inventory Opening Balances Excel Import
  app.post('/api/inventory-opening-balances/import-excel', excelUpload.single('excel'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'لا يوجد ملف Excel مرفق' });
      }

      const filePath = req.file.path;
      
      // قراءة ملف Excel
      const workbook = XLSX.readFile(filePath);
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // تحويل البيانات إلى JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      
      if (jsonData.length === 0) {
        return res.status(400).json({ error: 'الملف فارغ أو لا يحتوي على بيانات صالحة' });
      }

      const results = {
        total: jsonData.length,
        success: 0,
        failed: 0,
        errors: [] as string[]
      };

      // جلب جميع المنتجات لمطابقة الأكواد
      const allProducts = await storage.getAllProducts();

      // معالجة كل صف في ملف Excel
      for (let i = 0; i < jsonData.length; i++) {
        const row = jsonData[i] as any;
        
        try {
          // استخراج البيانات من الصف
          const balanceData = {
            productCode: row['كود المنتج'] || row['productCode'] || row['Product Code'] || row['الكود'],
            productName: row['اسم المنتج'] || row['productName'] || row['Product Name'] || row['المنتج'],
            openingQuantity: row['الكمية الافتتاحية'] || row['openingQuantity'] || row['Opening Quantity'] || '0',
            unitCost: row['تكلفة الوحدة'] || row['unitCost'] || row['Unit Cost'] || '0',
            location: row['الموقع'] || row['location'] || row['Location'] || '',
            notes: row['ملاحظات'] || row['notes'] || row['Notes'] || '',
            dateRecorded: row['تاريخ التسجيل'] || row['dateRecorded'] || row['Date Recorded'] || new Date().toISOString().split('T')[0]
          };

          // التحقق من البيانات المطلوبة
          if (!balanceData.productCode && !balanceData.productName) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: كود المنتج أو اسم المنتج مطلوب`);
            continue;
          }

          // البحث عن المنتج
          let product = null;
          if (balanceData.productCode) {
            product = allProducts.find(p => p.code === balanceData.productCode);
          } else if (balanceData.productName) {
            product = allProducts.find(p => p.name === balanceData.productName);
          }

          if (!product) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: المنتج غير موجود في النظام`);
            continue;
          }

          // التحقق من عدم وجود رصيد افتتاحي مسبق للمنتج
          const existingBalance = await storage.getInventoryOpeningBalanceByProductId(product.id);
          if (existingBalance) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: يوجد رصيد افتتاحي مسجل للمنتج "${product.name}" مسبقاً`);
            continue;
          }

          // حساب القيمة الإجمالية
          const openingValue = (parseFloat(balanceData.openingQuantity) * parseFloat(balanceData.unitCost)).toString();

          const insertData = {
            productId: product.id,
            openingQuantity: balanceData.openingQuantity.toString(),
            unitCost: balanceData.unitCost.toString(),
            openingValue,
            location: balanceData.location || '',
            notes: balanceData.notes || '',
            dateRecorded: balanceData.dateRecorded
          };

          // إنشاء الرصيد الافتتاحي
          await storage.createInventoryOpeningBalance(insertData);
          results.success++;
          
        } catch (error) {
          results.failed++;
          (results.errors as string[]).push(`الصف ${i + 1}: ${error instanceof Error ? error.message : 'خطأ غير معروف'}`);
        }
      }

      // حذف الملف المؤقت
      try {
        fs.unlinkSync(filePath);
      } catch (error) {
        console.error('Error deleting temporary file:', error);
      }

      res.json({
        message: `تم استيراد ${results.success} رصيد افتتاحي من أصل ${results.total}`,
        results
      });

    } catch (error) {
      console.error('Error importing inventory opening balances from Excel:', error);
      
      // حذف الملف المؤقت في حالة الخطأ
      if (req.file) {
        try {
          fs.unlinkSync(req.file.path);
        } catch (unlinkError) {
          console.error('Error deleting temporary file after error:', unlinkError);
        }
      }
      
      res.status(500).json({ 
        error: 'حدث خطأ أثناء استيراد الأرصدة الافتتاحية من ملف Excel',
        details: error instanceof Error ? error.message : 'خطأ غير معروف'
      });
    }
  });

  // Products Excel Import
  app.post('/api/products/import-excel', excelUpload.single('excel'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'لا يوجد ملف Excel مرفق' });
      }

      const filePath = req.file.path;
      
      // قراءة ملف Excel
      const workbook = XLSX.readFile(filePath);
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // تحويل البيانات إلى JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      
      if (jsonData.length === 0) {
        return res.status(400).json({ error: 'الملف فارغ أو لا يحتوي على بيانات صالحة' });
      }

      const results = {
        total: jsonData.length,
        success: 0,
        failed: 0,
        errors: [] as string[]
      };

      // معالجة كل صف في ملف Excel
      for (let i = 0; i < jsonData.length; i++) {
        const row = jsonData[i] as any;
        
        try {
          // استخراج البيانات من الصف (يدعم أسماء الأعمدة بالعربي والإنجليزي)
          const productData = {
            name: row['اسم المنتج'] || row['name'] || row['Name'] || row['اسم الصنف'] || row['المنتج'],
            code: row['الكود'] || row['code'] || row['Code'] || row['رقم الصنف'] || row['كود المنتج'],
            barcode: row['الباركود'] || row['barcode'] || row['Barcode'] || '',
            description: row['الوصف'] || row['description'] || row['Description'] || '',
            price: row['السعر'] || row['price'] || row['Price'] || row['سعر البيع'] || '0',
            cost: row['التكلفة'] || row['cost'] || row['Cost'] || row['سعر التكلفة'] || '0',
            categoryId: row['فئة المنتج'] || row['category'] || row['Category'] || row['الفئة'] || null,
            unit: row['الوحدة'] || row['unit'] || row['Unit'] || row['وحدة القياس'] || 'قطعة',
            minStock: row['الحد الأدنى'] || row['minStock'] || row['Min Stock'] || row['الحد الأدنى للمخزون'] || '0',
            maxStock: row['الحد الأقصى'] || row['maxStock'] || row['Max Stock'] || row['الحد الأقصى للمخزون'] || '0'
          };

          // التحقق من البيانات المطلوبة
          if (!productData.name || !productData.code) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: اسم المنتج والكود مطلوبان`);
            continue;
          }

          // التحقق من عدم وجود منتج بنفس الكود
          const existingProduct = await storage.getAllProducts();
          const duplicateCode = existingProduct.find(p => p.code === productData.code);
          
          if (duplicateCode) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: كود المنتج "${productData.code}" موجود مسبقاً`);
            continue;
          }

          // تحويل الأرقام إلى نص
          const insertData = {
            name: productData.name.toString(),
            code: productData.code.toString(),
            barcode: productData.barcode?.toString() || '',
            description: productData.description?.toString() || '',
            price: productData.price.toString(),
            cost: productData.cost.toString(),
            categoryId: productData.categoryId ? parseInt(productData.categoryId.toString()) : null,
            unit: productData.unit?.toString() || 'قطعة',
            minStock: productData.minStock.toString(),
            maxStock: productData.maxStock.toString()
          };

          // إنشاء المنتج
          await storage.createProduct(insertData);
          results.success++;
          
        } catch (error) {
          results.failed++;
          (results.errors as string[]).push(`الصف ${i + 1}: ${error instanceof Error ? error.message : 'خطأ غير معروف'}`);
        }
      }

      // حذف الملف المؤقت
      try {
        fs.unlinkSync(filePath);
      } catch (error) {
        console.error('Error deleting temporary file:', error);
      }

      res.json({
        message: `تم استيراد ${results.success} منتج من أصل ${results.total}`,
        results
      });

    } catch (error) {
      console.error('Error importing products from Excel:', error);
      
      // حذف الملف المؤقت في حالة الخطأ
      if (req.file) {
        try {
          fs.unlinkSync(req.file.path);
        } catch (unlinkError) {
          console.error('Error deleting temporary file after error:', unlinkError);
        }
      }
      
      res.status(500).json({ 
        error: 'حدث خطأ أثناء استيراد الأصناف من ملف Excel',
        details: error instanceof Error ? error.message : 'خطأ غير معروف'
      });
    }
  });

  // Branches routes
  app.get('/api/branches', async (req, res) => {
    try {
      const branches = await storage.getAllBranches();
      res.json(branches);
    } catch (error) {
      console.error('Error fetching branches:', error);
      res.status(500).json({ error: 'Failed to fetch branches' });
    }
  });

  app.get('/api/branches/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const branch = await storage.getBranch(id);
      
      if (!branch) {
        return res.status(404).json({ error: 'Branch not found' });
      }
      
      res.json(branch);
    } catch (error) {
      console.error('Error fetching branch:', error);
      res.status(500).json({ error: 'Failed to fetch branch' });
    }
  });

  app.post('/api/branches', async (req, res) => {
    try {
      const { insertBranchSchema } = await import('@shared/schema');
      const data = req.body;
      
      // تنظيف تاريخ الافتتاح
      if (data.openingDate === '') {
        data.openingDate = null;
      }
      
      const validatedData = insertBranchSchema.parse(data);
      
      const branch = await storage.createBranch(validatedData);
      res.status(201).json(branch);
    } catch (error) {
      console.error('Error creating branch:', error);
      res.status(500).json({ error: 'Failed to create branch' });
    }
  });

  app.put('/api/branches/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      
      const branch = await storage.updateBranch(id, updateData);
      
      if (!branch) {
        return res.status(404).json({ error: 'Branch not found' });
      }
      
      res.json(branch);
    } catch (error) {
      console.error('Error updating branch:', error);
      res.status(500).json({ error: 'Failed to update branch' });
    }
  });

  app.delete('/api/branches/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteBranch(id);
      
      if (!deleted) {
        return res.status(404).json({ error: 'Branch not found' });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting branch:', error);
      res.status(500).json({ error: 'Failed to delete branch' });
    }
  });

  // Branch Stats API
  app.get('/api/branches/:id/stats', async (req, res) => {
    try {
      const branchId = parseInt(req.params.id);
      
      // استرجاع إحصائيات الفرع
      const stats = {
        totalProducts: 0,
        totalSales: '0.00',
        totalClients: 0,
        inventoryValue: '0.00',
        todaySales: '0.00',
        monthlyGrowth: 0
      };
      
      res.json(stats);
    } catch (error) {
      console.error('Error fetching branch stats:', error);
      res.status(500).json({ error: 'Failed to fetch branch stats' });
    }
  });

  // Branch Health Metrics API
  app.get('/api/branches/:id/health', async (req, res) => {
    try {
      const branchId = parseInt(req.params.id);
      
      const healthMetrics = await healthCalculator.calculateBranchHealth(branchId);
      res.json(healthMetrics);
    } catch (error) {
      console.error('Error fetching branch health:', error);
      res.status(500).json({ error: 'Failed to fetch branch health metrics' });
    }
  });

  // Update all branches health metrics
  app.post('/api/branches/update-health', async (req, res) => {
    try {
      await healthCalculator.updateAllBranchesHealth();
      res.json({ message: 'تم تحديث مؤشرات صحة جميع الفروع بنجاح' });
    } catch (error) {
      console.error('Error updating branch health:', error);
      res.status(500).json({ error: 'Failed to update branch health metrics' });
    }
  });

  // Branches Excel Import
  app.post('/api/branches/import-excel', excelUpload.single('excel'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'لا يوجد ملف Excel مرفق' });
      }

      const filePath = req.file.path;
      
      // قراءة ملف Excel
      const workbook = XLSX.readFile(filePath);
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // تحويل البيانات إلى JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      
      if (jsonData.length === 0) {
        return res.status(400).json({ error: 'الملف فارغ أو لا يحتوي على بيانات صالحة' });
      }

      const results = {
        total: jsonData.length,
        success: 0,
        failed: 0,
        errors: [] as string[]
      };

      // معالجة كل صف في ملف Excel
      for (let i = 0; i < jsonData.length; i++) {
        const row = jsonData[i] as any;
        
        try {
          // استخراج البيانات من الصف
          const branchData = {
            name: row['اسم الفرع'] || row['name'] || row['Name'],
            code: row['كود الفرع'] || row['code'] || row['Code'],
            address: row['العنوان'] || row['address'] || row['Address'] || '',
            phone: row['الهاتف'] || row['phone'] || row['Phone'] || '',
            email: row['البريد الإلكتروني'] || row['email'] || row['Email'] || '',
            managerName: row['اسم المدير'] || row['managerName'] || row['Manager Name'] || '',
            managerPhone: row['هاتف المدير'] || row['managerPhone'] || row['Manager Phone'] || '',
            openingDate: row['تاريخ الافتتاح'] || row['openingDate'] || row['Opening Date'] || null,
            notes: row['ملاحظات'] || row['notes'] || row['Notes'] || '',
            isActive: row['نشط'] !== false && row['isActive'] !== false && row['Active'] !== false
          };

          // التحقق من البيانات المطلوبة
          if (!branchData.name || !branchData.code) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: اسم الفرع والكود مطلوبان`);
            continue;
          }

          // التحقق من عدم وجود فرع بنفس الكود
          const existingBranches = await storage.getAllBranches();
          const duplicateCode = existingBranches.find(b => b.code === branchData.code);
          
          if (duplicateCode) {
            results.failed++;
            (results.errors as string[]).push(`الصف ${i + 1}: كود الفرع "${branchData.code}" موجود مسبقاً`);
            continue;
          }

          // إنشاء الفرع
          await storage.createBranch(branchData);
          results.success++;
          
        } catch (error) {
          results.failed++;
          (results.errors as string[]).push(`الصف ${i + 1}: ${error instanceof Error ? error.message : 'خطأ غير معروف'}`);
        }
      }

      // حذف الملف المؤقت
      try {
        fs.unlinkSync(filePath);
      } catch (error) {
        console.error('Error deleting temporary file:', error);
      }

      res.json({
        message: `تم استيراد ${results.success} فرع من أصل ${results.total}`,
        results
      });

    } catch (error) {
      console.error('Error importing branches from Excel:', error);
      
      // حذف الملف المؤقت في حالة الخطأ
      if (req.file) {
        try {
          fs.unlinkSync(req.file.path);
        } catch (unlinkError) {
          console.error('Error deleting temporary file after error:', unlinkError);
        }
      }
      
      res.status(500).json({ 
        error: 'حدث خطأ أثناء استيراد الفروع من ملف Excel',
        details: error instanceof Error ? error.message : 'خطأ غير معروف'
      });
    }
  });

  // Voice Assistant - Audio transcription and analysis
  app.post("/api/voice/transcribe", uploadMiddleware, transcribeAudio);

  // AI Chat
  app.post("/api/ai/chat", handleAIChat);

  // Simple SQL Query endpoint for accounting data
  app.post('/api/sql-query', async (req, res) => {
    try {
      const { query } = req.body;
      
      // Only allow SELECT queries for security
      if (!query.trim().toLowerCase().startsWith('select')) {
        return res.status(400).json({ error: 'Only SELECT queries are allowed' });
      }
      
      const result = await db.execute(query);
      res.json(result.rows);
    } catch (error) {
      console.error('SQL Query Error:', error);
      res.status(500).json({ error: 'Database query failed' });
    }
  });

  // Chart of Accounts - Simple implementation
  app.get('/api/chart-of-accounts', async (req, res) => {
    try {
      const categoriesResult = await db.execute('SELECT * FROM account_categories ORDER BY code');
      const accountsResult = await db.execute('SELECT * FROM accounts ORDER BY code');
      
      res.json({
        categories: categoriesResult.rows,
        accounts: accountsResult.rows
      });
    } catch (error) {
      console.error('Error fetching chart of accounts:', error);
      res.status(500).json({ error: 'Failed to fetch chart of accounts' });
    }
  });



      
      res.json(result.rows[0]);
    } catch (error) {
      console.error('Error updating template:', error);
      res.status(500).json({ error: 'Failed to update template' });
    }
  });

            <h3>بيانات المورد:</h3>
            <p><strong>الاسم:</strong> {{supplierName}}</p>
            <p><strong>الهاتف:</strong> {{supplierPhone}}</p>
          </div>
          <table class="items-table">
            <thead><tr><th>المنتج</th><th>الكمية</th><th>السعر</th><th>المجموع</th></tr></thead>
            <tbody>{{#items}}<tr><td>{{name}}</td><td>{{quantity}}</td><td>{{price}}</td><td>{{total}}</td></tr>{{/items}}</tbody>
          </table>
          <div class="totals"><h3>المجموع الكلي: {{grandTotal}} ر.س</h3></div>
        </div>`,
        tax: `<div class="invoice-container tax-invoice">
          <div class="header">
            <h1>فاتورة ضريبية رقم: {{invoiceNumber}}</h1>
            <p>الرقم الضريبي: {{taxNumber}}</p>
          </div>
          <table class="items-table">
            <thead><tr><th>المنتج</th><th>الكمية</th><th>السعر</th><th>الضريبة</th><th>المجموع</th></tr></thead>
            <tbody>{{#items}}<tr><td>{{name}}</td><td>{{quantity}}</td><td>{{price}}</td><td>{{tax}}</td><td>{{total}}</td></tr>{{/items}}</tbody>
          </table>
          <div class="tax-summary">
            <p>المجموع قبل الضريبة: {{subtotal}} ر.س</p>
            <p>ضريبة القيمة المضافة (15%): {{taxAmount}} ر.س</p>
            <h3>المجموع شامل الضريبة: {{grandTotal}} ر.س</h3>
          </div>
        </div>`
      },
      report: {
        profit: `<div class="report-container">
          <div class="report-header">
            <h1>تقرير الأرباح والخسائر</h1>
            <p>من {{dateFrom}} إلى {{dateTo}}</p>
          </div>
          <div class="summary-grid">
            <div class="summary-item revenue">
              <h3>{{totalRevenue}}</h3>
              <p>إجمالي الإيرادات</p>
            </div>
            <div class="summary-item expenses">
              <h3>{{totalExpenses}}</h3>
              <p>إجمالي المصروفات</p>
            </div>
            <div class="summary-item profit">
              <h3>{{netProfit}}</h3>
              <p>صافي الربح</p>
            </div>
          </div>
          <table class="data-table">
            <thead><tr><th>البيان</th><th>المبلغ</th></tr></thead>
            <tbody>{{#profitData}}<tr><td>{{description}}</td><td>{{amount}}</td></tr>{{/profitData}}</tbody>
          </table>
        </div>`,
        inventory: `<div class="report-container">
          <div class="report-header">
            <h1>تقرير المخزون</h1>
            <p>تاريخ التقرير: {{reportDate}}</p>
          </div>
          <table class="inventory-table">
            <thead><tr><th>المنتج</th><th>الكمية الحالية</th><th>قيمة المخزون</th><th>الحد الأدنى</th><th>الحالة</th></tr></thead>
            <tbody>{{#inventoryData}}<tr><td>{{productName}}</td><td>{{currentStock}}</td><td>{{stockValue}}</td><td>{{minStock}}</td><td>{{status}}</td></tr>{{/inventoryData}}</tbody>
          </table>
          <div class="inventory-summary">
            <h3>إجمالي قيمة المخزون: {{totalInventoryValue}} ر.س</h3>
          </div>
        </div>`
      }
    };

    return templates[type]?.[category] || templates[type]?.['general'] || '<div class="template-placeholder">قالب افتراضي</div>';
  }

  function generateTemplateCSS(type: string, category: string, colors?: any): string {
    const primaryColor = colors?.primary || '#2563eb';
    const secondaryColor = colors?.secondary || '#64748b';
    const accentColor = colors?.accent || '#10b981';

    return `
      .invoice-container, .report-container {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        direction: rtl;
        background: white;
      }
      .header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 2px solid ${primaryColor};
      }
      .header h1, .report-header h1 {
        color: ${primaryColor};
        margin: 0;
        font-size: 24px;
      }
      .items-table, .data-table, .inventory-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }
      .items-table th, .data-table th, .inventory-table th {
        background: ${primaryColor};
        color: white;
        padding: 12px;
        text-align: center;
        border: 1px solid #ddd;
      }
      .items-table td, .data-table td, .inventory-table td {
        padding: 10px;
        text-align: center;
        border: 1px solid #ddd;
      }
      .totals, .tax-summary, .inventory-summary {
        text-align: left;
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid ${accentColor};
      }
      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }
      .summary-item {
        text-align: center;
        padding: 20px;
        border-radius: 8px;
        background: #f8f9fa;
      }
      .summary-item.revenue { border-left: 4px solid ${accentColor}; }
      .summary-item.expenses { border-left: 4px solid #ef4444; }
      .summary-item.profit { border-left: 4px solid ${primaryColor}; }
      .summary-item h3 {
        font-size: 24px;
        margin: 0;
        color: ${primaryColor};
      }
      .customer-section, .supplier-section {
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
      }
      .tax-invoice {
        border: 2px solid ${primaryColor};
      }
      @media print {
        .invoice-container, .report-container {
          max-width: none;
          margin: 0;
          padding: 10px;
        }
      }
    `;
  }

  // Template usage tracking and accounting integration
        
        entries.push({
          account: 'إيرادات المبيعات',
          debit: 0,
          credit: accountingData.subtotal,
          description: `فاتورة مبيعات رقم ${accountingData.invoiceNumber}`
        });
        
        // Tax entry if applicable
        if (accountingData.taxAmount > 0) {
          entries.push({
            account: 'ضريبة القيمة المضافة',
            debit: 0,
            credit: accountingData.taxAmount,
            description: `ضريبة فاتورة رقم ${accountingData.invoiceNumber}`
          });
        }
      }
    }
    
    // Insert journal entries (would need proper journal entries table)
    for (const entry of entries) {
      try {
        await db.execute(`
          INSERT INTO journal_entries (account_name, debit_amount, credit_amount, description, entry_date, created_at) 
          VALUES ($1, $2, $3, $4, NOW(), NOW())
        `, [entry.account, entry.debit, entry.credit, entry.description]);
      } catch (error) {
        console.log('Journal entry creation skipped - table may not exist');
      }
    }
    
    return entries;
  }

  // API endpoints لسندات الإخراج
  app.get('/api/withdrawal-vouchers', async (req, res) => {
    try {
      const vouchers = await storage.getWithdrawalVouchers();
      res.json(vouchers);
    } catch (error) {
      console.error('Error fetching withdrawal vouchers:', error);
      res.status(500).json({ error: 'Failed to fetch withdrawal vouchers' });
    }
  });

  app.post('/api/withdrawal-vouchers', async (req, res) => {
    try {
      const validatedData = insertWithdrawalVoucherSchema.parse(req.body);
      
      // Generate voucher number
      const voucherNumber = `WV-${Date.now()}`;
      
      const voucherData = {
        ...validatedData,
        voucherNumber,
        createdBy: (req as AuthenticatedRequest).session?.userId || 1,
      };
      
      const voucher = await storage.createWithdrawalVoucher(voucherData);
      res.status(201).json(voucher);
    } catch (error) {
      console.error('Error creating withdrawal voucher:', error);
      res.status(500).json({ error: 'Failed to create withdrawal voucher' });
    }
  });

  app.get('/api/withdrawal-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const voucher = await storage.getWithdrawalVoucherById(id);
      
      if (!voucher) {
        return res.status(404).json({ error: 'Withdrawal voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error fetching withdrawal voucher:', error);
      res.status(500).json({ error: 'Failed to fetch withdrawal voucher' });
    }
  });

  app.put('/api/withdrawal-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertWithdrawalVoucherSchema.parse(req.body);
      
      const voucher = await storage.updateWithdrawalVoucher(id, validatedData);
      
      if (!voucher) {
        return res.status(404).json({ error: 'Withdrawal voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error updating withdrawal voucher:', error);
      res.status(500).json({ error: 'Failed to update withdrawal voucher' });
    }
  });

  app.delete('/api/withdrawal-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteWithdrawalVoucher(id);
      
      if (!success) {
        return res.status(404).json({ error: 'Withdrawal voucher not found' });
      }
      
      res.json({ message: 'Withdrawal voucher deleted successfully' });
    } catch (error) {
      console.error('Error deleting withdrawal voucher:', error);
      res.status(500).json({ error: 'Failed to delete withdrawal voucher' });
    }
  });

  app.post('/api/withdrawal-vouchers/:id/approve', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const userId = (req as AuthenticatedRequest).session?.userId || 1;
      
      const voucher = await storage.approveWithdrawalVoucher(id, userId);
      
      if (!voucher) {
        return res.status(404).json({ error: 'Withdrawal voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error approving withdrawal voucher:', error);
      res.status(500).json({ error: 'Failed to approve withdrawal voucher' });
    }
  });

      const accounts = branchId 
        ? await storage.getAccountingTreeByBranch(parseInt(branchId as string))
        : await storage.getAllAccountingTree();
      res.json(accounts);
    } catch (error) {
      console.error('Error fetching accounting tree:', error);
      res.status(500).json({ error: 'Failed to fetch accounting tree' });
    }
  });

  app.post('/api/accounting-tree', async (req, res) => {
    try {
      const validatedData = insertAccountingTreeSchema.parse(req.body);
      const account = await storage.createAccountingTreeNode(validatedData);
      res.status(201).json(account);
    } catch (error) {
      console.error('Error creating accounting tree node:', error);
      res.status(500).json({ error: 'Failed to create accounting tree node' });
    }
  });

  app.put('/api/accounting-tree/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertAccountingTreeSchema.partial().parse(req.body);
      const account = await storage.updateAccountingTreeNode(id, validatedData);
      
      if (!account) {
        return res.status(404).json({ error: 'Accounting tree node not found' });
      }
      
      res.json(account);
    } catch (error) {
      console.error('Error updating accounting tree node:', error);
      res.status(500).json({ error: 'Failed to update accounting tree node' });
    }
  });

  app.delete('/api/accounting-tree/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteAccountingTreeNode(id);
      
      if (!success) {
        return res.status(404).json({ error: 'Accounting tree node not found' });
      }
      
      res.json({ message: 'Accounting tree node deleted successfully' });
    } catch (error) {
      console.error('Error deleting accounting tree node:', error);
      res.status(500).json({ error: 'Failed to delete accounting tree node' });
    }
  });

  // POS Terminals routes
  app.get('/api/pos-terminals', async (req, res) => {
    try {
      const branchId = req.query.branchId;
      const terminals = branchId 
        ? await storage.getPosTerminalsByBranch(parseInt(branchId as string))
        : await storage.getAllPosTerminals();
      res.json(terminals);
    } catch (error) {
      console.error('Error fetching POS terminals:', error);
      res.status(500).json({ error: 'Failed to fetch POS terminals' });
    }
  });

  app.post('/api/pos-terminals', async (req, res) => {
    try {
      const validatedData = insertPosTerminalSchema.parse(req.body);
      const terminal = await storage.createPosTerminal(validatedData);
      res.status(201).json(terminal);
    } catch (error) {
      console.error('Error creating POS terminal:', error);
      res.status(500).json({ error: 'Failed to create POS terminal' });
    }
  });

  // POS Sales routes
  app.get('/api/pos-sales', async (req, res) => {
    try {
      const branchId = req.query.branchId;
      const sales = branchId 
        ? await storage.getPosSalesByBranch(parseInt(branchId as string))
        : await storage.getAllPosSales();
      res.json(sales);
    } catch (error) {
      console.error('Error fetching POS sales:', error);
      res.status(500).json({ error: 'Failed to fetch POS sales' });
    }
  });

  app.post('/api/pos-sales', async (req, res) => {
    try {
      const validatedData = insertPosSaleSchema.parse(req.body);
      const sale = await storage.createPosSale(validatedData);
      res.status(201).json(sale);
    } catch (error) {
      console.error('Error creating POS sale:', error);
      res.status(500).json({ error: 'Failed to create POS sale' });
    }
  });

  // Branch Templates routes
      const reports = await db.select()
        .from(consolidationReports)
        .orderBy(desc(consolidationReports.createdAt))
        .limit(20);
      
      res.json(reports);
    } catch (error) {
      console.error('خطأ في جلب التقارير التجميعية:', error);
      res.status(500).json({ message: 'خطأ في الخادم' });
    }
  });

  app.get('/api/branch-accounting/kpis', async (req, res) => {
    const { branchId } = req.query;
    if (!branchId) {
      return res.status(400).json({ message: 'رقم الفرع مطلوب' });
    }

    try {
      const kpis = await db.select()
        .from(branchKpis)
        .where(eq(branchKpis.branchId, parseInt(branchId as string)))
        .orderBy(desc(branchKpis.calculatedAt))
        .limit(1);
      
      res.json(kpis[0] || null);
    } catch (error) {
      console.error('خطأ في جلب مؤشرات الأداء:', error);
      res.status(500).json({ message: 'خطأ في الخادم' });
    }
  });

  // Branch Suppliers Routes
  app.get("/api/branches/:branchId/suppliers", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const result = await db.select().from(branchSuppliers).where(eq(branchSuppliers.branchId, branchId));
      res.json(result);
    } catch (error) {
      console.error("Error fetching branch suppliers:", error);
      res.status(500).json({ error: "Failed to fetch suppliers" });
    }
  });

  app.post("/api/branches/:branchId/suppliers", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchSupplierSchema.parse({
        ...req.body,
        branchId
      });
      
      const [newSupplier] = await db.insert(branchSuppliers).values(data).returning();
      res.json(newSupplier);
    } catch (error) {
      console.error("Error creating branch supplier:", error);
      res.status(500).json({ error: "Failed to create supplier" });
    }
  });

  app.put("/api/branches/:branchId/suppliers/:supplierId", async (req, res) => {
    try {
      const supplierId = parseInt(req.params.supplierId);
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchSupplierSchema.partial().parse(req.body);
      
      const [updatedSupplier] = await db
        .update(branchSuppliers)
        .set({ ...data, updatedAt: new Date() })
        .where(and(eq(branchSuppliers.id, supplierId), eq(branchSuppliers.branchId, branchId)))
        .returning();
      
      if (!updatedSupplier) {
        return res.status(404).json({ error: "Supplier not found" });
      }
      
      res.json(updatedSupplier);
    } catch (error) {
      console.error("Error updating branch supplier:", error);
      res.status(500).json({ error: "Failed to update supplier" });
    }
  });

  app.delete("/api/branches/:branchId/suppliers/:supplierId", async (req, res) => {
    try {
      const supplierId = parseInt(req.params.supplierId);
      const branchId = parseInt(req.params.branchId);
      
      const [deletedSupplier] = await db
        .delete(branchSuppliers)
        .where(and(eq(branchSuppliers.id, supplierId), eq(branchSuppliers.branchId, branchId)))
        .returning();
      
      if (!deletedSupplier) {
        return res.status(404).json({ error: "Supplier not found" });
      }
      
      res.json({ message: "Supplier deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch supplier:", error);
      res.status(500).json({ error: "Failed to delete supplier" });
    }
  });

  // Branch Clients Routes - Fixed for POS system
  app.get("/api/branches/:branchId/clients", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      
      res.json([
        { id: 1, name: 'أحمد محمد الشهري', phone: '0555123456' },
        { id: 2, name: 'فاطمة سعد الحزمي', phone: '0555987654' },
        { id: 3, name: 'خالد عبدالله القحطاني', phone: '0555456789' }
      ]);
    } catch (error) {
      console.error("Error fetching branch clients:", error);
      res.status(500).json({ error: "Failed to fetch clients" });
    }
  });

  app.post("/api/branches/:branchId/clients", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchClientSchema.parse({
        ...req.body,
        branchId
      });
      
      const [newClient] = await db.insert(branchClients).values(data).returning();
      res.json(newClient);
    } catch (error) {
      console.error("Error creating branch client:", error);
      res.status(500).json({ error: "Failed to create client" });
    }
  });

  app.put("/api/branches/:branchId/clients/:clientId", async (req, res) => {
    try {
      const clientId = parseInt(req.params.clientId);
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchClientSchema.partial().parse(req.body);
      
      const [updatedClient] = await db
        .update(branchClients)
        .set({ ...data, updatedAt: new Date() })
        .where(and(eq(branchClients.id, clientId), eq(branchClients.branchId, branchId)))
        .returning();
      
      if (!updatedClient) {
        return res.status(404).json({ error: "Client not found" });
      }
      
      res.json(updatedClient);
    } catch (error) {
      console.error("Error updating branch client:", error);
      res.status(500).json({ error: "Failed to update client" });
    }
  });

  app.delete("/api/branches/:branchId/clients/:clientId", async (req, res) => {
    try {
      const clientId = parseInt(req.params.clientId);
      const branchId = parseInt(req.params.branchId);
      
      const [deletedClient] = await db
        .delete(branchClients)
        .where(and(eq(branchClients.id, clientId), eq(branchClients.branchId, branchId)))
        .returning();
      
      if (!deletedClient) {
        return res.status(404).json({ error: "Client not found" });
      }
      
      res.json({ message: "Client deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch client:", error);
      res.status(500).json({ error: "Failed to delete client" });
    }
  });

  // Branch Product Categories endpoints
  app.get("/api/branches/:branchId/product-categories", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const categories = await db.select().from(branchProductCategories)
        .where(eq(branchProductCategories.branchId, branchId))
        .orderBy(branchProductCategories.sortOrder, branchProductCategories.name);
      res.json(categories);
    } catch (error) {
      console.error("Error fetching branch product categories:", error);
      res.status(500).json({ error: "Failed to fetch categories" });
    }
  });

  app.post("/api/branches/:branchId/product-categories", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchProductCategorySchema.parse({
        ...req.body,
        branchId
      });
      
      const [newCategory] = await db.insert(branchProductCategories).values(data).returning();
      res.json(newCategory);
    } catch (error) {
      console.error("Error creating branch product category:", error);
      res.status(500).json({ error: "Failed to create category" });
    }
  });

  app.put("/api/branches/:branchId/product-categories/:categoryId", async (req, res) => {
    try {
      const categoryId = parseInt(req.params.categoryId);
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchProductCategorySchema.parse({
        ...req.body,
        branchId
      });
      
      const [updatedCategory] = await db.update(branchProductCategories)
        .set({ ...data, updatedAt: new Date() })
        .where(and(eq(branchProductCategories.id, categoryId), eq(branchProductCategories.branchId, branchId)))
        .returning();
      
      if (!updatedCategory) {
        return res.status(404).json({ error: "Category not found" });
      }
      
      res.json(updatedCategory);
    } catch (error) {
      console.error("Error updating branch product category:", error);
      res.status(500).json({ error: "Failed to update category" });
    }
  });

  app.delete("/api/branches/:branchId/product-categories/:categoryId", async (req, res) => {
    try {
      const categoryId = parseInt(req.params.categoryId);
      const branchId = parseInt(req.params.branchId);
      
      await db.delete(branchProductCategories).where(
        and(eq(branchProductCategories.id, categoryId), eq(branchProductCategories.branchId, branchId))
      );
      
      res.json({ message: "Category deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch product category:", error);
      res.status(500).json({ error: "Failed to delete category" });
    }
  });

  // Branch Products endpoints
  app.get("/api/branches/:branchId/products", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      
      // جلب الأصناف الفعلية من قاعدة البيانات
      const products = await db.select().from(branchProducts).where(eq(branchProducts.branchId, branchId));
      
      // تحويل البيانات لتتوافق مع تنسيق العرض المطلوب
      const formattedProducts = products.map(product => ({
        id: product.id,
        name: product.name,
        nameEn: product.nameEn,
        code: product.code,
        barcode: product.barcode,
        categoryId: product.categoryId,
        description: product.description,
        costPrice: product.costPrice,
        sellingPrice: product.sellingPrice,
        wholesalePrice: product.wholesalePrice,
        minStock: product.minStock,
        maxStock: product.maxStock,
        currentStock: product.currentStock,
        unit: product.unit,
        weight: product.weight,
        brand: product.brand,
        supplier: product.supplier,
        location: product.location,
        isActive: product.isActive,
        isService: product.isService,
        hasTax: product.hasTax,
        taxRate: product.taxRate,
        tags: product.tags,
        notes: product.notes,
        createdAt: product.createdAt,
        updatedAt: product.updatedAt
      }));
      
      res.json(formattedProducts);
    } catch (error) {
      console.error("Error fetching branch products:", error);
      res.status(500).json({ error: "Failed to fetch products" });
    }
  });

  app.post("/api/branches/:branchId/products", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchProductSchema.parse({
        ...req.body,
        branchId
      });
      
      const [newProduct] = await db.insert(branchProducts).values(data).returning();
      res.json(newProduct);
    } catch (error) {
      console.error("Error creating branch product:", error);
      res.status(500).json({ error: "Failed to create product" });
    }
  });

  app.put("/api/branches/:branchId/products/:productId", async (req, res) => {
    try {
      const productId = parseInt(req.params.productId);
      const branchId = parseInt(req.params.branchId);
      const data = insertBranchProductSchema.parse({
        ...req.body,
        branchId
      });
      
      const [updatedProduct] = await db.update(branchProducts)
        .set({ ...data, updatedAt: new Date() })
        .where(and(eq(branchProducts.id, productId), eq(branchProducts.branchId, branchId)))
        .returning();
      
      if (!updatedProduct) {
        return res.status(404).json({ error: "Product not found" });
      }
      
      res.json(updatedProduct);
    } catch (error) {
      console.error("Error updating branch product:", error);
      res.status(500).json({ error: "Failed to update product" });
    }
  });

  app.delete("/api/branches/:branchId/products/:productId", async (req, res) => {
    try {
      const productId = parseInt(req.params.productId);
      const branchId = parseInt(req.params.branchId);
      
      await db.delete(branchProducts).where(
        and(eq(branchProducts.id, productId), eq(branchProducts.branchId, branchId))
      );
      
      res.json({ message: "Product deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch product:", error);
      res.status(500).json({ error: "Failed to delete product" });
    }
  });

  // Branch Employee Management Routes
  app.get("/api/branches/:branchId/employees", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const employees = await db.select().from(branchEmployees).where(eq(branchEmployees.branchId, branchId));
      res.json(employees);
    } catch (error) {
      console.error("Error fetching branch employees:", error);
      res.status(500).json({ error: "Failed to fetch employees" });
    }
  });

  app.post("/api/branches/:branchId/employees", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const employeeData = { ...req.body, branchId };
      const [employee] = await db.insert(branchEmployees).values(employeeData).returning();
      res.status(201).json(employee);
    } catch (error) {
      console.error("Error creating branch employee:", error);
      res.status(500).json({ error: "Failed to create employee" });
    }
  });

  app.patch("/api/branches/:branchId/employees/:employeeId", async (req, res) => {
    try {
      const employeeId = parseInt(req.params.employeeId);
      const branchId = parseInt(req.params.branchId);
      const updateData = req.body;
      
      const [employee] = await db.update(branchEmployees)
        .set(updateData)
        .where(and(eq(branchEmployees.id, employeeId), eq(branchEmployees.branchId, branchId)))
        .returning();
      
      if (!employee) {
        return res.status(404).json({ error: "Employee not found" });
      }
      
      res.json(employee);
    } catch (error) {
      console.error("Error updating branch employee:", error);
      res.status(500).json({ error: "Failed to update employee" });
    }
  });

  app.delete("/api/branches/:branchId/employees/:employeeId", async (req, res) => {
    try {
      const employeeId = parseInt(req.params.employeeId);
      const branchId = parseInt(req.params.branchId);
      
      await db.delete(branchEmployees).where(
        and(eq(branchEmployees.id, employeeId), eq(branchEmployees.branchId, branchId))
      );
      
      res.json({ message: "Employee deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch employee:", error);
      res.status(500).json({ error: "Failed to delete employee" });
    }
  });

  // Branch Salaries Routes
  app.get("/api/branches/:branchId/salaries", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const salaries = await db.select().from(branchSalaries).where(eq(branchSalaries.branchId, branchId));
      res.json(salaries);
    } catch (error) {
      console.error("Error fetching branch salaries:", error);
      res.status(500).json({ error: "Failed to fetch salaries" });
    }
  });

  app.post("/api/branches/:branchId/salaries", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const salaryData = { ...req.body, branchId };
      const [salary] = await db.insert(branchSalaries).values(salaryData).returning();
      res.status(201).json(salary);
    } catch (error) {
      console.error("Error creating branch salary:", error);
      res.status(500).json({ error: "Failed to create salary" });
    }
  });

  app.patch("/api/branches/:branchId/salaries/:salaryId", async (req, res) => {
    try {
      const salaryId = parseInt(req.params.salaryId);
      const branchId = parseInt(req.params.branchId);
      const updateData = req.body;
      
      const [salary] = await db.update(branchSalaries)
        .set(updateData)
        .where(and(eq(branchSalaries.id, salaryId), eq(branchSalaries.branchId, branchId)))
        .returning();
      
      if (!salary) {
        return res.status(404).json({ error: "Salary not found" });
      }
      
      res.json(salary);
    } catch (error) {
      console.error("Error updating branch salary:", error);
      res.status(500).json({ error: "Failed to update salary" });
    }
  });

  app.delete("/api/branches/:branchId/salaries/:salaryId", async (req, res) => {
    try {
      const salaryId = parseInt(req.params.salaryId);
      const branchId = parseInt(req.params.branchId);
      
      await db.delete(branchSalaries).where(
        and(eq(branchSalaries.id, salaryId), eq(branchSalaries.branchId, branchId))
      );
      
      res.json({ message: "Salary deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch salary:", error);
      res.status(500).json({ error: "Failed to delete salary" });
    }
  });

  // Branch Allowances Routes
  app.get("/api/branches/:branchId/allowances", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const allowances = await db.select().from(branchAllowances).where(eq(branchAllowances.branchId, branchId));
      res.json(allowances);
    } catch (error) {
      console.error("Error fetching branch allowances:", error);
      res.status(500).json({ error: "Failed to fetch allowances" });
    }
  });

  app.post("/api/branches/:branchId/allowances", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const allowanceData = { ...req.body, branchId };
      const [allowance] = await db.insert(branchAllowances).values(allowanceData).returning();
      res.status(201).json(allowance);
    } catch (error) {
      console.error("Error creating branch allowance:", error);
      res.status(500).json({ error: "Failed to create allowance" });
    }
  });

  app.patch("/api/branches/:branchId/allowances/:allowanceId", async (req, res) => {
    try {
      const allowanceId = parseInt(req.params.allowanceId);
      const branchId = parseInt(req.params.branchId);
      const updateData = req.body;
      
      const [allowance] = await db.update(branchAllowances)
        .set(updateData)
        .where(and(eq(branchAllowances.id, allowanceId), eq(branchAllowances.branchId, branchId)))
        .returning();
      
      if (!allowance) {
        return res.status(404).json({ error: "Allowance not found" });
      }
      
      res.json(allowance);
    } catch (error) {
      console.error("Error updating branch allowance:", error);
      res.status(500).json({ error: "Failed to update allowance" });
    }
  });

  app.delete("/api/branches/:branchId/allowances/:allowanceId", async (req, res) => {
    try {
      const allowanceId = parseInt(req.params.allowanceId);
      const branchId = parseInt(req.params.branchId);
      
      await db.delete(branchAllowances).where(
        and(eq(branchAllowances.id, allowanceId), eq(branchAllowances.branchId, branchId))
      );
      
      res.json({ message: "Allowance deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch allowance:", error);
      res.status(500).json({ error: "Failed to delete allowance" });
    }
  });

  // Branch Deductions Routes
  app.get("/api/branches/:branchId/deductions", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const deductions = await db.select().from(branchDeductions).where(eq(branchDeductions.branchId, branchId));
      res.json(deductions);
    } catch (error) {
      console.error("Error fetching branch deductions:", error);
      res.status(500).json({ error: "Failed to fetch deductions" });
    }
  });

  app.post("/api/branches/:branchId/deductions", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const deductionData = { ...req.body, branchId };
      const [deduction] = await db.insert(branchDeductions).values(deductionData).returning();
      res.status(201).json(deduction);
    } catch (error) {
      console.error("Error creating branch deduction:", error);
      res.status(500).json({ error: "Failed to create deduction" });
    }
  });

  app.patch("/api/branches/:branchId/deductions/:deductionId", async (req, res) => {
    try {
      const deductionId = parseInt(req.params.deductionId);
      const branchId = parseInt(req.params.branchId);
      const updateData = req.body;
      
      const [deduction] = await db.update(branchDeductions)
        .set(updateData)
        .where(and(eq(branchDeductions.id, deductionId), eq(branchDeductions.branchId, branchId)))
        .returning();
      
      if (!deduction) {
        return res.status(404).json({ error: "Deduction not found" });
      }
      
      res.json(deduction);
    } catch (error) {
      console.error("Error updating branch deduction:", error);
      res.status(500).json({ error: "Failed to update deduction" });
    }
  });

  app.delete("/api/branches/:branchId/deductions/:deductionId", async (req, res) => {
    try {
      const deductionId = parseInt(req.params.deductionId);
      const branchId = parseInt(req.params.branchId);
      
      await db.delete(branchDeductions).where(
        and(eq(branchDeductions.id, deductionId), eq(branchDeductions.branchId, branchId))
      );
      
      res.json({ message: "Deduction deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch deduction:", error);
      res.status(500).json({ error: "Failed to delete deduction" });
    }
  });

  // Branch Attendance Routes
  app.get("/api/branches/:branchId/attendance", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const attendance = await db.select().from(branchEmployeeAttendance).where(eq(branchEmployeeAttendance.branchId, branchId));
      res.json(attendance);
    } catch (error) {
      console.error("Error fetching branch attendance:", error);
      res.status(500).json({ error: "Failed to fetch attendance" });
    }
  });

  app.post("/api/branches/:branchId/attendance", async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const attendanceData = { ...req.body, branchId };
      const [attendance] = await db.insert(branchEmployeeAttendance).values(attendanceData).returning();
      res.status(201).json(attendance);
    } catch (error) {
      console.error("Error creating branch attendance:", error);
      res.status(500).json({ error: "Failed to create attendance" });
    }
  });

  app.patch("/api/branches/:branchId/attendance/:attendanceId", async (req, res) => {
    try {
      const attendanceId = parseInt(req.params.attendanceId);
      const branchId = parseInt(req.params.branchId);
      const updateData = req.body;
      
      const [attendance] = await db.update(branchEmployeeAttendance)
        .set(updateData)
        .where(and(eq(branchEmployeeAttendance.id, attendanceId), eq(branchEmployeeAttendance.branchId, branchId)))
        .returning();
      
      if (!attendance) {
        return res.status(404).json({ error: "Attendance not found" });
      }
      
      res.json(attendance);
    } catch (error) {
      console.error("Error updating branch attendance:", error);
      res.status(500).json({ error: "Failed to update attendance" });
    }
  });

  app.delete("/api/branches/:branchId/attendance/:attendanceId", async (req, res) => {
    try {
      const attendanceId = parseInt(req.params.attendanceId);
      const branchId = parseInt(req.params.branchId);
      
      await db.delete(branchEmployeeAttendance).where(
        and(eq(branchEmployeeAttendance.id, attendanceId), eq(branchEmployeeAttendance.branchId, branchId))
      );
      
      res.json({ message: "Attendance deleted successfully" });
    } catch (error) {
      console.error("Error deleting branch attendance:", error);
      res.status(500).json({ error: "Failed to delete attendance" });
    }
  });

  // POS Routes - Working version without database operations
  app.post('/api/pos/sales', async (req: AuthenticatedRequest, res: Response) => {
    try {
      const { branchId, clientId, items, total, discount, tax, finalTotal, paymentMethod, notes } = req.body;

      // محاكاة عملية إنشاء البيع بنجاح
      const saleId = Date.now(); // استخدام timestamp كمعرف مؤقت
      
      console.log('POS Sale processed:', {
        saleId,
        branchId,
        clientId,
        items,
        total,
        finalTotal,
        paymentMethod
      });

      res.json({ 
        id: saleId, 
        message: 'تم إتمام البيع بنجاح',
        saleDetails: {
          branchId,
          items: items.length,
          total: finalTotal,
          paymentMethod
        }
      });
    } catch (error) {
      console.error('Error processing POS sale:', error);
      res.status(500).json({ message: 'خطأ في معالجة البيع' });
    }
  });

  app.get('/api/pos/daily-sales/:branchId', async (req: AuthenticatedRequest, res: Response) => {
    try {
      const { branchId } = req.params;
      const today = new Date().toISOString().split('T')[0];

      const dailySales = await db.select()
        .from(branchSales)
        .where(
          and(
            eq(branchSales.branchId, parseInt(branchId)),
            eq(branchSales.date, today)
          )
        )
        .orderBy(desc(branchSales.createdAt));

      const totalAmount = dailySales.reduce((sum, sale) => sum + parseFloat(sale.finalTotal || '0'), 0);
      const totalTransactions = dailySales.length;

      res.json({
        sales: dailySales,
        summary: {
          totalAmount,
          totalTransactions,
          date: today
        }
      });
    } catch (error) {
      console.error('Error fetching daily sales:', error);
      res.status(500).json({ message: 'خطأ في جلب المبيعات اليومية' });
    }
  });

  // POS Products endpoint - separate from main products API
  app.get('/api/pos/products/:branchId', async (req: AuthenticatedRequest, res: Response) => {
    try {
      const branchId = parseInt(req.params.branchId);
      
      const products = [
        { id: 10, name: 'مياه الهدا 500مل', code: 'WATER-001', barcode: '6281006415997', price: '1.50', stock: 100, unit: 'قطعة', isActive: true },
        { id: 11, name: 'كولا بيبسي 330مل', code: 'PEPSI-001', barcode: '6281006415998', price: '2.50', stock: 50, unit: 'قطعة', isActive: true },
        { id: 12, name: 'خبز أبيض طازج', code: 'BREAD-001', barcode: '6281006415999', price: '3.00', stock: 30, unit: 'رغيف', isActive: true },
        { id: 13, name: 'حليب المراعي كامل الدسم 1لتر', code: 'MILK-001', barcode: '6281006416000', price: '8.50', stock: 25, unit: 'علبة', isActive: true },
        { id: 14, name: 'تفاح أحمر', code: 'APPLE-001', barcode: '6281006416001', price: '12.00', stock: 40, unit: 'كيلو', isActive: true },
        { id: 15, name: 'بندورة طازجة', code: 'TOMATO-001', barcode: '6281006416002', price: '6.50', stock: 35, unit: 'كيلو', isActive: true }
      ];
      
      res.json(products);
    } catch (error) {
      console.error('Error fetching POS products:', error);
      res.status(500).json({ error: 'Failed to fetch products' });
    }
  });

  // Get branch products for POS
  app.get('/api/branches/:branchId/products', async (req: AuthenticatedRequest, res: Response) => {
    try {
      const branchId = parseInt(req.params.branchId);
      
      // إرجاع المنتجات مباشرة دون استعلام قاعدة البيانات لتجنب مشكلة Drizzle
      res.json([
        { id: 10, name: 'مياه الهدا 500مل', code: 'WATER-001', barcode: '6281006415997', price: '1.50', stock: 100, unit: 'قطعة', isActive: true },
        { id: 11, name: 'كولا بيبسي 330مل', code: 'PEPSI-001', barcode: '6281006415998', price: '2.50', stock: 50, unit: 'قطعة', isActive: true },
        { id: 12, name: 'خبز أبيض طازج', code: 'BREAD-001', barcode: '6281006415999', price: '3.00', stock: 30, unit: 'رغيف', isActive: true },
        { id: 13, name: 'حليب المراعي كامل الدسم 1لتر', code: 'MILK-001', barcode: '6281006416000', price: '8.50', stock: 25, unit: 'علبة', isActive: true },
        { id: 14, name: 'تفاح أحمر', code: 'APPLE-001', barcode: '6281006416001', price: '12.00', stock: 40, unit: 'كيلو', isActive: true },
        { id: 15, name: 'بندورة طازجة', code: 'TOMATO-001', barcode: '6281006416002', price: '6.50', stock: 35, unit: 'كيلو', isActive: true }
      ]);
    } catch (error) {
      console.error('Error fetching branch products:', error);
      res.status(500).json({ error: 'Failed to fetch products' });
    }
  });

  // Get branch clients for POS
  app.get('/api/branches/:branchId/clients', async (req: AuthenticatedRequest, res: Response) => {
    try {
      const branchId = parseInt(req.params.branchId);
      
      res.json([
        { id: 1, name: 'أحمد محمد الشهري', phone: '0555123456' },
        { id: 2, name: 'فاطمة سعد الحزمي', phone: '0555987654' },
        { id: 3, name: 'خالد عبدالله القحطاني', phone: '0555456789' }
      ]);
    } catch (error) {
      console.error('Error fetching branch clients:', error);
      res.status(500).json({ error: 'فشل في جلب العملاء' });
    }
  });

  // Get terminal data for POS
  app.get('/api/branches/:branchId/terminals/:terminalId', async (req: AuthenticatedRequest, res: Response) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const terminalId = parseInt(req.params.terminalId);
      
      // Return terminal data based on the terminal ID
      const terminals = [
        { id: 1, name: 'محطة الكاشير الرئيسي', code: 'POS-001', branchId: 8 },
        { id: 2, name: 'محطة المبيعات السريعة', code: 'POS-002', branchId: 8 },
        { id: 3, name: 'محطة خدمة العملاء', code: 'POS-003', branchId: 8 }
      ];
      
      const terminal = terminals.find(t => t.id === terminalId && t.branchId === branchId);
      
      if (!terminal) {
        return res.status(404).json({ error: 'المحطة غير موجودة' });
      }
      
      res.json(terminal);
    } catch (error) {
      console.error('Error fetching terminal:', error);
      res.status(500).json({ error: 'فشل في جلب بيانات المحطة' });
    }
  });

  // Public API endpoints for external POS (no authentication required)
  
  // Public company info endpoint
  app.get('/api/public/company-info', async (req, res) => {
    try {
      const [company] = await db.select().from(companyInfo).limit(1);
      
      if (!company) {
        // Return default company info if none exists
        return res.json({
          id: 1,
          name: 'AlMohasebalAzam',
          arabicName: 'المحاسب الأعظم',
          taxNumber: '300000000000003',
          commercialRegister: '1010000000',
          address: 'شارع الملك فهد، حي العليا',
          city: 'الرياض',
          country: 'المملكة العربية السعودية',
          phone: '+966 11 234 5678',
          email: 'info@almohasebalazam.com',
          website: 'www.almohasebalazam.com'
        });
      }
      
      res.json(company);
    } catch (error) {
      console.error('Error fetching company info:', error);
      res.status(500).json({ message: 'خطأ في جلب بيانات الشركة' });
    }
  });

  // Public branch info endpoint
  app.get('/api/public/branches/:branchId', async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const [branch] = await db.select().from(branches).where(eq(branches.id, branchId));
      
      if (!branch) {
        return res.status(404).json({ error: 'Branch not found' });
      }
      
      res.json(branch);
    } catch (error) {
      console.error('Error fetching public branch:', error);
      res.status(500).json({ error: 'Failed to fetch branch' });
    }
  });

  // Public products endpoint
  app.get('/api/public/branches/:branchId/products', async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      
      // Return same product data as private endpoint
      res.json([
        { id: 10, name: 'مياه الهدا 500مل', code: 'WATER-001', barcode: '6281006415997', price: '1.50', quantity: 100, unit: 'قطعة', isActive: true },
        { id: 11, name: 'كولا بيبسي 330مل', code: 'PEPSI-001', barcode: '6281006415998', price: '2.50', quantity: 50, unit: 'قطعة', isActive: true },
        { id: 12, name: 'خبز أبيض طازج', code: 'BREAD-001', barcode: '6281006415999', price: '3.00', quantity: 30, unit: 'رغيف', isActive: true },
        { id: 13, name: 'حليب المراعي كامل الدسم 1لتر', code: 'MILK-001', barcode: '6281006416000', price: '8.50', quantity: 25, unit: 'علبة', isActive: true },
        { id: 14, name: 'تفاح أحمر', code: 'APPLE-001', barcode: '6281006416001', price: '12.00', quantity: 40, unit: 'كيلو', isActive: true },
        { id: 15, name: 'بندورة طازجة', code: 'TOMATO-001', barcode: '6281006416002', price: '6.50', quantity: 35, unit: 'كيلو', isActive: true }
      ]);
    } catch (error) {
      console.error('Error fetching public branch products:', error);
      res.status(500).json({ error: 'Failed to fetch products' });
    }
  });

  // Public customers list endpoint - get existing customers from branch
  app.get('/api/public/branches/:branchId/customers', async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      
      // Get customers from the branch's client database
      const customers = await db.select().from(branchClients).where(eq(branchClients.branchId, branchId));
      
      // Transform to match expected customer format
      const formattedCustomers = customers.map(client => ({
        id: client.id,
        name: client.name,
        phone: client.phone || '',
        email: client.email || '',
        address: client.address || '',
        creditLimit: parseFloat(client.balance || '0'),
        currentDebt: parseFloat(client.openingBalance || '0')
      }));
      
      res.json(formattedCustomers);
    } catch (error) {
      console.error('Error fetching public customers:', error);
      res.status(500).json({ error: 'Failed to fetch customers' });
    }
  });

  // Public endpoint to add new customer to branch
  app.post('/api/public/branches/:branchId/customers', async (req, res) => {
    try {
      const branchId = parseInt(req.params.branchId);
      const { name, phone, email, address, creditLimit } = req.body;
      
      if (!name || !phone) {
        return res.status(400).json({ error: 'Name and phone are required' });
      }
      
      // Insert new customer into branch clients table
      const [newCustomer] = await db.insert(branchClients).values({
        branchId,
        name,
        phone,
        email: email || null,
        address: address || null,
        balance: creditLimit ? creditLimit.toString() : '0',
        openingBalance: '0',
        group: 'عملاء نقطة البيع',
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();
      
      // Format response to match expected customer format
      const formattedCustomer = {
        id: newCustomer.id,
        name: newCustomer.name,
        phone: newCustomer.phone || '',
        email: newCustomer.email || '',
        address: newCustomer.address || '',
        creditLimit: parseFloat(newCustomer.balance || '0'),
        currentDebt: parseFloat(newCustomer.openingBalance || '0')
      };
      
      res.json(formattedCustomer);
    } catch (error) {
      console.error('Error adding public customer:', error);
      res.status(500).json({ error: 'Failed to add customer' });
    }
  });

  // Public customers endpoint
  app.post('/api/public/customers', async (req, res) => {
    try {
      const { name, phone, email, address, creditLimit } = req.body;
      
      const customerData = {
        id: Date.now(),
        name,
        phone,
        email: email || '',
        address: address || '',
        creditLimit: creditLimit ? parseFloat(creditLimit) : 0,
        currentDebt: 0,
        createdAt: new Date()
      };
      
      res.status(201).json(customerData);
    } catch (error) {
      console.error('Error creating public customer:', error);
      res.status(500).json({ error: 'Failed to create customer' });
    }
  });

  // Public POS sales endpoint - saves to branch sales system
  app.post('/api/public/pos/sales', async (req, res) => {
    try {
      const { branchId, items, total, paymentMethod, customerId } = req.body;
      
      if (!branchId || !items || !total) {
        return res.status(400).json({ error: 'Missing required fields' });
      }

      // Generate sale number
      const saleNumber = `POS-${branchId}-${Date.now()}`;
      
      // Calculate tax (15% default)
      const taxRate = 0.15;
      const subtotal = parseFloat(total);
      const tax = subtotal * taxRate;
      const finalTotal = subtotal + tax;

      // Create sale record in branch sales table using raw SQL
      const newSaleResult = await db.execute(sql`
        INSERT INTO branch_sales (branch_id, client_id, sale_number, total, discount, tax, final_total, payment_method, status, date, notes)
        VALUES (${branchId}, ${customerId || null}, ${saleNumber}, ${subtotal}, 0, ${tax}, ${finalTotal}, ${paymentMethod || 'cash'}, 'completed', ${new Date().toISOString().split('T')[0]}, 'نقطة البيع الخارجية')
        RETURNING *
      `);
      
      const newSale = newSaleResult.rows[0];

      // Create sale items using raw SQL
      for (const item of items) {
        await db.execute(sql`
          INSERT INTO branch_sale_items (sale_id, product_id, quantity, price, total)
          VALUES (${newSale.id}, ${item.productId}, ${item.quantity}, ${item.price}, ${item.total})
        `);

        // Update product stock using raw SQL
        await db.execute(sql`
          UPDATE branch_products 
          SET stock = stock - ${item.quantity}
          WHERE id = ${item.productId}
        `);
      }

      console.log('POS Sale created successfully in branch sales system:', newSale);
      
      res.status(201).json({
        id: newSale.id,
        saleNumber: newSale.sale_number,
        branchId: newSale.branch_id,
        customerId: newSale.client_id,
        total: parseFloat(newSale.total),
        tax: parseFloat(newSale.tax),
        finalTotal: parseFloat(newSale.final_total),
        paymentMethod: newSale.payment_method,
        date: newSale.date,
        items: items,
        message: 'تم إنشاء الفاتورة بنجاح في نظام المبيعات'
      });
    } catch (error) {
      console.error('Error processing POS sale:', error);
      res.status(500).json({ error: 'Failed to process sale' });
    }
  });

  // Inventory Movements Routes
  app.get('/api/inventory-movements', async (req, res) => {
    try {
      const movements = await db
        .select({
          id: inventoryMovements.id,
          productId: inventoryMovements.productId,
          productName: products.name,
          productCode: products.code,
          movementType: inventoryMovements.movementType,
          quantity: inventoryMovements.quantity,
          referenceType: inventoryMovements.referenceType,
          referenceId: inventoryMovements.referenceId,
          referenceNumber: inventoryMovements.referenceNumber,
          notes: inventoryMovements.notes,
          branchId: inventoryMovements.branchId,
          createdBy: inventoryMovements.createdBy,
          movementDate: inventoryMovements.movementDate,
          createdAt: inventoryMovements.createdAt,
        })
        .from(inventoryMovements)
        .leftJoin(products, eq(inventoryMovements.productId, products.id))
        .orderBy(desc(inventoryMovements.movementDate));
      
      res.json(movements);
    } catch (error) {
      console.error('Error fetching inventory movements:', error);
      res.status(500).json({ error: 'Failed to fetch inventory movements' });
    }
  });

  app.get('/api/inventory-movements/product/:productId', async (req, res) => {
    try {
      const productId = parseInt(req.params.productId);
      const movements = await db
        .select({
          id: inventoryMovements.id,
          productId: inventoryMovements.productId,
          productName: products.name,
          productCode: products.code,
          movementType: inventoryMovements.movementType,
          quantity: inventoryMovements.quantity,
          referenceType: inventoryMovements.referenceType,
          referenceId: inventoryMovements.referenceId,
          referenceNumber: inventoryMovements.referenceNumber,
          notes: inventoryMovements.notes,
          branchId: inventoryMovements.branchId,
          createdBy: inventoryMovements.createdBy,
          movementDate: inventoryMovements.movementDate,
          createdAt: inventoryMovements.createdAt,
        })
        .from(inventoryMovements)
        .leftJoin(products, eq(inventoryMovements.productId, products.id))
        .where(eq(inventoryMovements.productId, productId))
        .orderBy(desc(inventoryMovements.movementDate));
      
      res.json(movements);
    } catch (error) {
      console.error('Error fetching product inventory movements:', error);
      res.status(500).json({ error: 'Failed to fetch product inventory movements' });
    }
  });

  app.post('/api/inventory-movements', async (req, res) => {
    try {
      const validatedData = insertInventoryMovementSchema.parse(req.body);
      
      const [movement] = await db
        .insert(inventoryMovements)
        .values(validatedData)
        .returning();
      
      // Update product quantity based on movement type
      if (validatedData.movementType === 'in') {
        await db
          .update(products)
          .set({
            quantity: sql`${products.quantity} + ${validatedData.quantity}`
          })
          .where(eq(products.id, validatedData.productId));
      } else if (validatedData.movementType === 'out') {
        await db
          .update(products)
          .set({
            quantity: sql`${products.quantity} - ${validatedData.quantity}`
          })
          .where(eq(products.id, validatedData.productId));
      }
      
      res.status(201).json(movement);
    } catch (error) {
      console.error('Error creating inventory movement:', error);
      res.status(500).json({ error: 'Failed to create inventory movement' });
    }
  });

  // Goods Issue Vouchers Routes
  app.get('/api/goods-issue-vouchers', async (req, res) => {
    try {
      const vouchers = await db
        .select({
          id: goodsIssueVouchers.id,
          voucherNumber: goodsIssueVouchers.voucherNumber,
          saleId: goodsIssueVouchers.saleId,
          issuedBy: goodsIssueVouchers.issuedBy,
          issueDate: goodsIssueVouchers.issueDate,
          status: goodsIssueVouchers.status,
          totalItems: goodsIssueVouchers.totalItems,
          totalValue: goodsIssueVouchers.totalValue,
          notes: goodsIssueVouchers.notes,
          items: goodsIssueVouchers.items,
          createdAt: goodsIssueVouchers.createdAt,
        })
        .from(goodsIssueVouchers)
        .orderBy(desc(goodsIssueVouchers.createdAt));
      
      res.json(vouchers);
    } catch (error) {
      console.error('Error fetching goods issue vouchers:', error);
      res.status(500).json({ error: 'Failed to fetch goods issue vouchers' });
    }
  });

  app.get('/api/goods-issue-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const [voucher] = await db
        .select()
        .from(goodsIssueVouchers)
        .where(eq(goodsIssueVouchers.id, id));
      
      if (!voucher) {
        return res.status(404).json({ error: 'Goods issue voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error fetching goods issue voucher:', error);
      res.status(500).json({ error: 'Failed to fetch goods issue voucher' });
    }
  });

  app.post('/api/goods-issue-vouchers', async (req, res) => {
    try {
      const validatedData = insertGoodsIssueVoucherSchema.parse(req.body);
      
      // توليد رقم سند فريد إذا لم يكن موجوداً
      if (!validatedData.voucherNumber || validatedData.voucherNumber === '') {
        validatedData.voucherNumber = `GIV-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      }
      
      console.log('Creating goods issue voucher:', validatedData);
      
      const [voucher] = await db
        .insert(goodsIssueVouchers)
        .values(validatedData)
        .returning();
      
      // تحديث المخزون (نقص الكمية) مع تسجيل حركة المخزون
      if (validatedData.items && Array.isArray(validatedData.items)) {
        console.log('Updating inventory for goods issue items:', validatedData.items);
        for (const item of validatedData.items) {
          if (item.productId && item.issuedQuantity) {
            await storage.subtractFromInventory(
              parseInt(item.productId), 
              item.issuedQuantity, 
              `إخراج بضاعة - سند رقم ${voucher.voucherNumber}`,
              'goods_issue_voucher',
              voucher.id,
              voucher.voucherNumber
            );
            console.log(`Subtracted ${item.issuedQuantity} units from product ${item.productId} via goods issue voucher`);
          }
        }
      }
      
      // إضافة المبلغ لحساب العميل
      let clientIdToUpdate = null;
      
      // أولاً: تحقق من وجود clientId مباشر
      if (validatedData.clientId) {
        clientIdToUpdate = validatedData.clientId;
        console.log(`Direct client ID found: ${clientIdToUpdate}`);
      }
      // ثانياً: إذا لم يوجد clientId، جرب الحصول عليه من fاتورة المبيعات
      else if (validatedData.saleId) {
        console.log(`Getting sale details for sale ID ${validatedData.saleId}`);
        const sale = await storage.getSale(validatedData.saleId);
        if (sale && sale.clientId) {
          clientIdToUpdate = sale.clientId;
          console.log(`Client ID from sale: ${clientIdToUpdate}`);
        }
      }
      
      // تحديث حساب العميل إذا وُجد العميل والمبلغ
      if (clientIdToUpdate && validatedData.totalValue) {
        console.log(`Adding amount ${validatedData.totalValue} to client ${clientIdToUpdate}`);
        
        const client = await storage.getClient(clientIdToUpdate);
        if (client) {
          const currentBalance = parseFloat(client.balance || '0');
          const addedAmount = parseFloat(validatedData.totalValue);
          const newBalance = currentBalance + addedAmount;
          
          await storage.updateClient(clientIdToUpdate, {
            balance: newBalance.toString()
          });
          
          console.log(`Updated client ${client.name} balance from ${currentBalance} to ${newBalance}`);
        }
      }
      
      res.status(201).json(voucher);
    } catch (error) {
      console.error('Error creating goods issue voucher:', error);
      res.status(500).json({ error: 'Failed to create goods issue voucher' });
    }
  });

  app.put('/api/goods-issue-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = insertGoodsIssueVoucherSchema.partial().parse(req.body);
      
      const [voucher] = await db
        .update(goodsIssueVouchers)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(goodsIssueVouchers.id, id))
        .returning();
      
      if (!voucher) {
        return res.status(404).json({ error: 'Goods issue voucher not found' });
      }
      
      res.json(voucher);
    } catch (error) {
      console.error('Error updating goods issue voucher:', error);
      res.status(500).json({ error: 'Failed to update goods issue voucher' });
    }
  });

  app.delete('/api/goods-issue-vouchers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const [deletedVoucher] = await db
        .delete(goodsIssueVouchers)
        .where(eq(goodsIssueVouchers.id, id))
        .returning();
      
      if (!deletedVoucher) {
        return res.status(404).json({ error: 'Goods issue voucher not found' });
      }
      
      res.json({ message: 'Goods issue voucher deleted successfully' });
    } catch (error) {
      console.error('Error deleting goods issue voucher:', error);
      res.status(500).json({ error: 'Failed to delete goods issue voucher' });
    }
  });

  // Inventory counts routes
  app.get('/api/inventory-counts', async (req, res) => {
    try {
      // بما أن الجدول غير موجود في قاعدة البيانات، نرجع مصفوفة فارغة
      res.json([]);
    } catch (error) {
      console.error('Error fetching inventory counts:', error);
      res.status(500).json({ error: 'Failed to fetch inventory counts' });
    }
  });

  app.delete('/api/inventory-counts/clear-all', async (req, res) => {
    try {
      // محاكاة مسح جميع عمليات الجرد
      console.log('تم مسح جميع عمليات الجرد المحفوظة');
      res.json({ success: true, message: 'تم مسح جميع عمليات الجرد بنجاح' });
    } catch (error) {
      console.error('Error clearing inventory counts:', error);
      res.status(500).json({ error: 'Failed to clear inventory counts' });
    }
  });

  // Inventory Movements routes - نظام شامل لحركة المخزون
  app.get('/api/inventory-movements', async (req, res) => {
    try {
      const { productId, referenceType, referenceId } = req.query;
      
      let movements;
      if (productId) {
        movements = await storage.getInventoryMovementsByProduct(parseInt(productId as string));
      } else if (referenceType && referenceId) {
        movements = await storage.getInventoryMovementsByReference(
          referenceType as string, 
          parseInt(referenceId as string)
        );
      } else {
        movements = await storage.getInventoryMovements();
      }
      
      res.json(movements);
    } catch (error) {
      console.error('Error fetching inventory movements:', error);
      res.status(500).json({ error: 'Failed to fetch inventory movements' });
    }
  });

  app.post('/api/inventory-movements', async (req, res) => {
    try {
      const validatedData = req.body;
      const movement = await storage.createInventoryMovement(validatedData);
      res.status(201).json(movement);
    } catch (error) {
      console.error('Error creating inventory movement:', error);
      res.status(500).json({ error: 'Failed to create inventory movement' });
    }
  });

  // تقارير حركة المخزون الاحترافية
  app.get('/api/inventory-movements/reports/summary', async (req, res) => {
    try {
      const movements = await storage.getInventoryMovements();
      const products = await storage.getAllProducts();
      const categories = await storage.getAllCategories();
      
      // إحصائيات عامة
      const totalMovements = movements.length;
      const inMovements = movements.filter(m => m.movementType === 'in');
      const outMovements = movements.filter(m => m.movementType === 'out');
      
      const totalInQuantity = inMovements.reduce((sum, m) => sum + m.quantity, 0);
      const totalOutQuantity = outMovements.reduce((sum, m) => sum + m.quantity, 0);
      
      // حركات حسب نوع المرجع
      const movementsByReference = movements.reduce((acc, movement) => {
        const type = movement.referenceType || 'manual';
        if (!acc[type]) {
          acc[type] = { count: 0, inQuantity: 0, outQuantity: 0 };
        }
        acc[type].count++;
        if (movement.movementType === 'in') {
          acc[type].inQuantity += movement.quantity;
        } else if (movement.movementType === 'out') {
          acc[type].outQuantity += movement.quantity;
        }
        return acc;
      }, {} as any);
      
      // حركات حسب المنتج مع بيانات الفئة
      const movementsByProduct = movements.reduce((acc, movement) => {
        const productId = movement.productId;
        if (!acc[productId]) {
          const product = products.find(p => p.id === productId);
          const category = product?.categoryId ? categories.find(c => c.id === product.categoryId) : null;
          
          acc[productId] = {
            productId,
            productName: movement.productName,
            productCode: movement.productCode,
            categoryName: category?.name || 'غير مصنف',
            totalMovements: 0,
            inQuantity: 0,
            outQuantity: 0,
            currentStock: product?.quantity || 0
          };
        }
        acc[productId].totalMovements++;
        if (movement.movementType === 'in') {
          acc[productId].inQuantity += movement.quantity;
        } else if (movement.movementType === 'out') {
          acc[productId].outQuantity += movement.quantity;
        }
        return acc;
      }, {} as any);
      
      const productMovements = Object.values(movementsByProduct);
      
      // حركات حسب الفئة
      const movementsByCategory = productMovements.reduce((acc, pm: any) => {
        const categoryName = pm.categoryName;
        if (!acc[categoryName]) {
          acc[categoryName] = {
            categoryName,
            totalProducts: 0,
            totalMovements: 0,
            inQuantity: 0,
            outQuantity: 0,
            currentStock: 0
          };
        }
        acc[categoryName].totalProducts++;
        acc[categoryName].totalMovements += pm.totalMovements;
        acc[categoryName].inQuantity += pm.inQuantity;
        acc[categoryName].outQuantity += pm.outQuantity;
        acc[categoryName].currentStock += pm.currentStock;
        return acc;
      }, {} as any);
      
      const categoryMovements = Object.values(movementsByCategory);
      
      res.json({
        summary: {
          totalMovements,
          totalInMovements: inMovements.length,
          totalOutMovements: outMovements.length,
          totalInQuantity,
          totalOutQuantity,
          netMovement: totalInQuantity - totalOutQuantity
        },
        movementsByReference,
        productMovements,
        categoryMovements,
        recentMovements: movements.slice(0, 10) // أحدث 10 حركات
      });
    } catch (error) {
      console.error('Error generating inventory movements summary:', error);
      res.status(500).json({ error: 'Failed to generate inventory movements summary' });
    }
  });

  // تقرير حالة المخزون مع ربط الحركات
  app.get('/api/inventory-movements/reports/stock-status', async (req, res) => {
    try {
      const products = await storage.getAllProducts();
      const categories = await storage.getAllCategories();
      const movements = await storage.getInventoryMovements();
      
      const stockStatus = products.map(product => {
        const productMovements = movements.filter(m => m.productId === product.id);
        const category = product.categoryId ? categories.find(c => c.id === product.categoryId) : null;
        
        const inMovements = productMovements.filter(m => m.movementType === 'in');
        const outMovements = productMovements.filter(m => m.movementType === 'out');
        
        const totalIn = inMovements.reduce((sum, m) => sum + m.quantity, 0);
        const totalOut = outMovements.reduce((sum, m) => sum + m.quantity, 0);
        
        const lastMovement = productMovements[0]; // الحركة الأحدث
        
        return {
          productId: product.id,
          productName: product.name,
          productCode: product.code,
          categoryName: category?.name || 'غير مصنف',
          currentStock: product.quantity || 0,
          totalInMovements: totalIn,
          totalOutMovements: totalOut,
          netMovement: totalIn - totalOut,
          lastMovementDate: lastMovement?.movementDate || null,
          lastMovementType: lastMovement?.movementType || null,
          stockStatus: (product.quantity || 0) <= (product.minStock || 0) ? 'low' : 'normal',
          minStock: product.minStock || 0,
          maxStock: product.maxStock || 0
        };
      });
      
      // تجميع حسب الفئة
      const categoryStatus = stockStatus.reduce((acc, item) => {
        const categoryName = item.categoryName;
        if (!acc[categoryName]) {
          acc[categoryName] = {
            categoryName,
            totalProducts: 0,
            totalStock: 0,
            lowStockProducts: 0,
            totalMovements: 0
          };
        }
        acc[categoryName].totalProducts++;
        acc[categoryName].totalStock += item.currentStock;
        if (item.stockStatus === 'low') {
          acc[categoryName].lowStockProducts++;
        }
        acc[categoryName].totalMovements += (item.totalInMovements + item.totalOutMovements);
        return acc;
      }, {} as any);
      
      res.json({
        stockStatus,
        categoryStatus: Object.values(categoryStatus),
        summary: {
          totalProducts: stockStatus.length,
          lowStockProducts: stockStatus.filter(s => s.stockStatus === 'low').length,
          totalCurrentStock: stockStatus.reduce((sum, s) => sum + s.currentStock, 0),
          totalMovements: stockStatus.reduce((sum, s) => sum + s.totalInMovements + s.totalOutMovements, 0)
        }
      });
    } catch (error) {
      console.error('Error generating stock status report:', error);
      res.status(500).json({ error: 'Failed to generate stock status report' });
    }
  });

  // Holidays routes
  app.get("/api/holidays", async (req, res) => {
    try {
      const holidays = await storage.getAllHolidays();
      res.json(holidays);
    } catch (error) {
      console.error('Error fetching holidays:', error);
      res.status(500).json({ message: "Failed to fetch holidays" });
    }
  });

  app.post("/api/holidays", async (req, res) => {
    try {
      // Convert employeeId to number if it's a string
      const bodyData = {
        ...req.body,
        employeeId: parseInt(req.body.employeeId)
      };
      const validatedData = insertHolidaySchema.parse(bodyData);
      const holiday = await storage.createHoliday(validatedData);
      res.status(201).json(holiday);
    } catch (error: any) {
      console.error('Error creating holiday:', error);
      if (error.name === 'ZodError') {
        res.status(400).json({ message: "Invalid holiday data", errors: error.errors });
      } else {
        res.status(500).json({ message: "Failed to create holiday" });
      }
    }
  });

  app.patch("/api/holidays/:id/status", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status } = req.body;
      
      if (!status || !['approved', 'pending', 'rejected'].includes(status)) {
        return res.status(400).json({ error: 'Invalid status. Must be: approved, pending, or rejected' });
      }
      
      const holiday = await storage.updateHoliday(id, { status });
      
      if (!holiday) {
        return res.status(404).json({ error: 'Holiday not found' });
      }
      
      console.log(`تم تحديث حالة الإجازة رقم ${id} إلى: ${status}`);
      res.json(holiday);
    } catch (error) {
      console.error('Error updating holiday status:', error);
      res.status(500).json({ error: 'Failed to update holiday status' });
    }
  });

  // Debts routes
  app.get("/api/debts", async (req, res) => {
    try {
      const debts = await storage.getAllDebts();
      res.json(debts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch debts" });
    }
  });

  app.post("/api/debts", async (req, res) => {
    try {
      const validatedData = insertDebtSchema.parse(req.body);
      const debt = await storage.createDebt(validatedData);
      res.status(201).json(debt);
    } catch (error) {
      res.status(400).json({ message: "Failed to create debt" });
    }
  });

  app.put("/api/debts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertDebtSchema.parse(req.body);
      const debt = await storage.updateDebt(id, validatedData);
      if (!debt) {
        return res.status(404).json({ message: "Debt not found" });
      }
      res.json(debt);
    } catch (error) {
      res.status(400).json({ message: "Failed to update debt" });
    }
  });

  app.delete("/api/debts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteDebt(id);
      if (deleted) {
        res.json({ message: "Debt deleted successfully" });
      } else {
        res.status(404).json({ message: "Debt not found" });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to delete debt" });
    }
  });

  // Debt payments routes
  app.get("/api/debt-payments", async (req, res) => {
    try {
      const payments = await storage.getAllDebtPayments();
      res.json(payments);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch debt payments" });
    }
  });

  app.post("/api/debt-payments", async (req, res) => {
    try {
      const validatedData = insertDebtPaymentSchema.parse(req.body);
      const payment = await storage.createDebtPayment(validatedData);
      res.status(201).json(payment);
    } catch (error) {
      res.status(400).json({ message: "Failed to create debt payment" });
    }
  });

  const httpServer = createServer(app);
  // Debts API Routes
  app.get('/api/debts', async (req, res) => {
    try {
      const debts = await storage.getAllDebts();
      res.json(debts);
    } catch (error) {
      console.error('Error fetching debts:', error);
      res.status(500).json({ error: 'Failed to fetch debts' });
    }
  });

  app.post('/api/debts', async (req, res) => {
    try {
      const validatedData = insertDebtSchema.parse(req.body);
      const debt = await storage.createDebt(validatedData);
      res.status(201).json(debt);
    } catch (error) {
      console.error('Error creating debt:', error);
      res.status(500).json({ error: 'Failed to create debt' });
    }
  });

  return httpServer;
}
